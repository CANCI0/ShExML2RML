/// Generated by rustemo. Do not edit manually!
use std::fmt::Debug;
use std::hash::Hash;
use rustemo::{
    Result, Input as InputT, Lexer, Token, TokenRecognizer as TokenRecognizerT, Parser,
    ParserDefinition, State as StateT, Builder,
};
use rustemo::regex::Regex;
use rustemo::once_cell::sync::Lazy;
use rustemo::StringLexer;
use rustemo::LRBuilder;
use super::shexml_actions;
use rustemo::{LRParser, LRContext};
use rustemo::Action::{self, Shift, Reduce, Accept};
#[allow(unused_imports)]
use rustemo::debug::{log, logn};
#[allow(unused_imports)]
#[cfg(debug_assertions)]
use rustemo::colored::*;
pub type Input = str;
const STATE_COUNT: usize = 94usize;
const MAX_RECOGNIZERS: usize = 7usize;
#[allow(dead_code)]
const TERMINAL_COUNT: usize = 22usize;
#[allow(clippy::upper_case_acronyms)]
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum TokenKind {
    #[default]
    STOP,
    PrefixLiteral,
    SourceLiteral,
    IteratorLiteral,
    FieldLiteral,
    ExpressionLiteral,
    UnionLiteral,
    OpenTag,
    CloseTag,
    OpenBrace,
    CloseBrace,
    OpenBracket,
    CloseBracket,
    AtSign,
    Dots,
    Semicolon,
    Namespace,
    Identifier,
    PathLiteral,
    Path,
    ShapePath,
    Uri,
}
use TokenKind as TK;
impl From<TokenKind> for usize {
    fn from(t: TokenKind) -> Self {
        t as usize
    }
}
#[allow(clippy::enum_variant_names)]
#[derive(Clone, Copy, PartialEq)]
pub enum ProdKind {
    ShexmlP1,
    Declaration1P1,
    Declaration1P2,
    Declaration0P1,
    Declaration0P2,
    Shape1P1,
    Shape1P2,
    Shape0P1,
    Shape0P2,
    DeclarationP1,
    DeclarationP2,
    DeclarationP3,
    DeclarationP4,
    PrefixP1,
    SourceP1,
    ExpressionP1,
    Path1P1,
    Path1P2,
    IteratorP1,
    Attribute1P1,
    Attribute1P2,
    Nestedterator1P1,
    Nestedterator1P2,
    Nestedterator0P1,
    Nestedterator0P2,
    NestedteratorP1,
    Iterator1P1,
    Iterator1P2,
    Iterator0P1,
    Iterator0P2,
    AttributeP1,
    ShapeP1,
    PredicateObject1P1,
    PredicateObject1P2,
    PredicateObject0P1,
    PredicateObject0P2,
    SubjectP1,
    ClassP1,
    SubjectIdentifierP1,
    NamespaceOptP1,
    NamespaceOptP2,
    PredicateObjectP1,
    PredicateP1,
    ObjectP1,
    ObjectP2,
    DataValueP1,
    ReferenceP1,
}
use ProdKind as PK;
impl std::fmt::Debug for ProdKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let name = match self {
            ProdKind::ShexmlP1 => "Shexml: Declaration0 Shape0",
            ProdKind::Declaration1P1 => "Declaration1: Declaration1 Declaration",
            ProdKind::Declaration1P2 => "Declaration1: Declaration",
            ProdKind::Declaration0P1 => "Declaration0: Declaration1",
            ProdKind::Declaration0P2 => "Declaration0: ",
            ProdKind::Shape1P1 => "Shape1: Shape1 Shape",
            ProdKind::Shape1P2 => "Shape1: Shape",
            ProdKind::Shape0P1 => "Shape0: Shape1",
            ProdKind::Shape0P2 => "Shape0: ",
            ProdKind::DeclarationP1 => "Declaration: Prefix",
            ProdKind::DeclarationP2 => "Declaration: Source",
            ProdKind::DeclarationP3 => "Declaration: Expression",
            ProdKind::DeclarationP4 => "Declaration: Iterator",
            ProdKind::PrefixP1 => "Prefix: PrefixLiteral Namespace OpenTag Uri CloseTag",
            ProdKind::SourceP1 => "Source: SourceLiteral Identifier OpenTag Uri CloseTag",
            ProdKind::ExpressionP1 => {
                "Expression: ExpressionLiteral Identifier OpenTag Path1 CloseTag"
            }
            ProdKind::Path1P1 => "Path1: Path1 UnionLiteral Path",
            ProdKind::Path1P2 => "Path1: Path",
            ProdKind::IteratorP1 => {
                "Iterator: IteratorLiteral Identifier OpenTag PathLiteral Path CloseTag OpenBrace Attribute1 Nestedterator0 CloseBrace"
            }
            ProdKind::Attribute1P1 => "Attribute1: Attribute1 Attribute",
            ProdKind::Attribute1P2 => "Attribute1: Attribute",
            ProdKind::Nestedterator1P1 => "Nestedterator1: Nestedterator1 Nestedterator",
            ProdKind::Nestedterator1P2 => "Nestedterator1: Nestedterator",
            ProdKind::Nestedterator0P1 => "Nestedterator0: Nestedterator1",
            ProdKind::Nestedterator0P2 => "Nestedterator0: ",
            ProdKind::NestedteratorP1 => {
                "Nestedterator: IteratorLiteral Identifier OpenTag Path CloseTag OpenBrace Attribute1 Iterator0 CloseBrace"
            }
            ProdKind::Iterator1P1 => "Iterator1: Iterator1 Iterator",
            ProdKind::Iterator1P2 => "Iterator1: Iterator",
            ProdKind::Iterator0P1 => "Iterator0: Iterator1",
            ProdKind::Iterator0P2 => "Iterator0: ",
            ProdKind::AttributeP1 => {
                "Attribute: FieldLiteral Identifier OpenTag Path CloseTag"
            }
            ProdKind::ShapeP1 => "Shape: Subject OpenBrace PredicateObject0 CloseBrace",
            ProdKind::PredicateObject1P1 => {
                "PredicateObject1: PredicateObject1 PredicateObject"
            }
            ProdKind::PredicateObject1P2 => "PredicateObject1: PredicateObject",
            ProdKind::PredicateObject0P1 => "PredicateObject0: PredicateObject1",
            ProdKind::PredicateObject0P2 => "PredicateObject0: ",
            ProdKind::SubjectP1 => "Subject: Class SubjectIdentifier",
            ProdKind::ClassP1 => "Class: Namespace Identifier",
            ProdKind::SubjectIdentifierP1 => {
                "SubjectIdentifier: NamespaceOpt OpenBracket ShapePath CloseBracket"
            }
            ProdKind::NamespaceOptP1 => "NamespaceOpt: Namespace",
            ProdKind::NamespaceOptP2 => "NamespaceOpt: ",
            ProdKind::PredicateObjectP1 => "PredicateObject: Predicate Object Semicolon",
            ProdKind::PredicateP1 => "Predicate: Namespace Identifier",
            ProdKind::ObjectP1 => "Object: DataValue",
            ProdKind::ObjectP2 => "Object: Reference",
            ProdKind::DataValueP1 => {
                "DataValue: NamespaceOpt OpenBracket ShapePath CloseBracket"
            }
            ProdKind::ReferenceP1 => "Reference: AtSign Dots Identifier",
        };
        write!(f, "{}", name)
    }
}
#[allow(clippy::upper_case_acronyms)]
#[allow(dead_code)]
#[derive(Clone, Copy, Debug)]
pub enum NonTermKind {
    EMPTY,
    AUG,
    Shexml,
    Declaration1,
    Declaration0,
    Shape1,
    Shape0,
    Declaration,
    Prefix,
    Source,
    Expression,
    Path1,
    Iterator,
    Attribute1,
    Nestedterator1,
    Nestedterator0,
    Nestedterator,
    Iterator1,
    Iterator0,
    Attribute,
    Shape,
    PredicateObject1,
    PredicateObject0,
    Subject,
    Class,
    SubjectIdentifier,
    NamespaceOpt,
    PredicateObject,
    Predicate,
    Object,
    DataValue,
    Reference,
}
impl From<ProdKind> for NonTermKind {
    fn from(prod: ProdKind) -> Self {
        match prod {
            ProdKind::ShexmlP1 => NonTermKind::Shexml,
            ProdKind::Declaration1P1 => NonTermKind::Declaration1,
            ProdKind::Declaration1P2 => NonTermKind::Declaration1,
            ProdKind::Declaration0P1 => NonTermKind::Declaration0,
            ProdKind::Declaration0P2 => NonTermKind::Declaration0,
            ProdKind::Shape1P1 => NonTermKind::Shape1,
            ProdKind::Shape1P2 => NonTermKind::Shape1,
            ProdKind::Shape0P1 => NonTermKind::Shape0,
            ProdKind::Shape0P2 => NonTermKind::Shape0,
            ProdKind::DeclarationP1 => NonTermKind::Declaration,
            ProdKind::DeclarationP2 => NonTermKind::Declaration,
            ProdKind::DeclarationP3 => NonTermKind::Declaration,
            ProdKind::DeclarationP4 => NonTermKind::Declaration,
            ProdKind::PrefixP1 => NonTermKind::Prefix,
            ProdKind::SourceP1 => NonTermKind::Source,
            ProdKind::ExpressionP1 => NonTermKind::Expression,
            ProdKind::Path1P1 => NonTermKind::Path1,
            ProdKind::Path1P2 => NonTermKind::Path1,
            ProdKind::IteratorP1 => NonTermKind::Iterator,
            ProdKind::Attribute1P1 => NonTermKind::Attribute1,
            ProdKind::Attribute1P2 => NonTermKind::Attribute1,
            ProdKind::Nestedterator1P1 => NonTermKind::Nestedterator1,
            ProdKind::Nestedterator1P2 => NonTermKind::Nestedterator1,
            ProdKind::Nestedterator0P1 => NonTermKind::Nestedterator0,
            ProdKind::Nestedterator0P2 => NonTermKind::Nestedterator0,
            ProdKind::NestedteratorP1 => NonTermKind::Nestedterator,
            ProdKind::Iterator1P1 => NonTermKind::Iterator1,
            ProdKind::Iterator1P2 => NonTermKind::Iterator1,
            ProdKind::Iterator0P1 => NonTermKind::Iterator0,
            ProdKind::Iterator0P2 => NonTermKind::Iterator0,
            ProdKind::AttributeP1 => NonTermKind::Attribute,
            ProdKind::ShapeP1 => NonTermKind::Shape,
            ProdKind::PredicateObject1P1 => NonTermKind::PredicateObject1,
            ProdKind::PredicateObject1P2 => NonTermKind::PredicateObject1,
            ProdKind::PredicateObject0P1 => NonTermKind::PredicateObject0,
            ProdKind::PredicateObject0P2 => NonTermKind::PredicateObject0,
            ProdKind::SubjectP1 => NonTermKind::Subject,
            ProdKind::ClassP1 => NonTermKind::Class,
            ProdKind::SubjectIdentifierP1 => NonTermKind::SubjectIdentifier,
            ProdKind::NamespaceOptP1 => NonTermKind::NamespaceOpt,
            ProdKind::NamespaceOptP2 => NonTermKind::NamespaceOpt,
            ProdKind::PredicateObjectP1 => NonTermKind::PredicateObject,
            ProdKind::PredicateP1 => NonTermKind::Predicate,
            ProdKind::ObjectP1 => NonTermKind::Object,
            ProdKind::ObjectP2 => NonTermKind::Object,
            ProdKind::DataValueP1 => NonTermKind::DataValue,
            ProdKind::ReferenceP1 => NonTermKind::Reference,
        }
    }
}
#[allow(clippy::enum_variant_names)]
#[derive(Default, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum State {
    #[default]
    AUGS0,
    PrefixLiteralS1,
    SourceLiteralS2,
    IteratorLiteralS3,
    ExpressionLiteralS4,
    ShexmlS5,
    Declaration1S6,
    Declaration0S7,
    DeclarationS8,
    PrefixS9,
    SourceS10,
    ExpressionS11,
    IteratorS12,
    NamespaceS13,
    IdentifierS14,
    IdentifierS15,
    IdentifierS16,
    DeclarationS17,
    NamespaceS18,
    Shape1S19,
    Shape0S20,
    ShapeS21,
    SubjectS22,
    ClassS23,
    OpenTagS24,
    OpenTagS25,
    OpenTagS26,
    OpenTagS27,
    IdentifierS28,
    ShapeS29,
    OpenBraceS30,
    NamespaceS31,
    SubjectIdentifierS32,
    NamespaceOptS33,
    UriS34,
    UriS35,
    PathLiteralS36,
    PathS37,
    Path1S38,
    NamespaceS39,
    PredicateObject1S40,
    PredicateObject0S41,
    PredicateObjectS42,
    PredicateS43,
    OpenBracketS44,
    CloseTagS45,
    CloseTagS46,
    PathS47,
    UnionLiteralS48,
    CloseTagS49,
    IdentifierS50,
    PredicateObjectS51,
    CloseBraceS52,
    AtSignS53,
    NamespaceOptS54,
    ObjectS55,
    DataValueS56,
    ReferenceS57,
    ShapePathS58,
    CloseTagS59,
    PathS60,
    DotsS61,
    OpenBracketS62,
    SemicolonS63,
    CloseBracketS64,
    OpenBraceS65,
    IdentifierS66,
    ShapePathS67,
    FieldLiteralS68,
    Attribute1S69,
    AttributeS70,
    CloseBracketS71,
    IdentifierS72,
    IteratorLiteralS73,
    Nestedterator1S74,
    Nestedterator0S75,
    NestedteratorS76,
    AttributeS77,
    OpenTagS78,
    IdentifierS79,
    NestedteratorS80,
    CloseBraceS81,
    PathS82,
    OpenTagS83,
    CloseTagS84,
    PathS85,
    CloseTagS86,
    OpenBraceS87,
    Attribute1S88,
    IteratorS89,
    Iterator1S90,
    Iterator0S91,
    IteratorS92,
    CloseBraceS93,
}
impl StateT for State {
    fn default_layout() -> Option<Self> {
        None
    }
}
impl From<State> for usize {
    fn from(s: State) -> Self {
        s as usize
    }
}
impl std::fmt::Debug for State {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let name = match self {
            State::AUGS0 => "0:AUG",
            State::PrefixLiteralS1 => "1:PrefixLiteral",
            State::SourceLiteralS2 => "2:SourceLiteral",
            State::IteratorLiteralS3 => "3:IteratorLiteral",
            State::ExpressionLiteralS4 => "4:ExpressionLiteral",
            State::ShexmlS5 => "5:Shexml",
            State::Declaration1S6 => "6:Declaration1",
            State::Declaration0S7 => "7:Declaration0",
            State::DeclarationS8 => "8:Declaration",
            State::PrefixS9 => "9:Prefix",
            State::SourceS10 => "10:Source",
            State::ExpressionS11 => "11:Expression",
            State::IteratorS12 => "12:Iterator",
            State::NamespaceS13 => "13:Namespace",
            State::IdentifierS14 => "14:Identifier",
            State::IdentifierS15 => "15:Identifier",
            State::IdentifierS16 => "16:Identifier",
            State::DeclarationS17 => "17:Declaration",
            State::NamespaceS18 => "18:Namespace",
            State::Shape1S19 => "19:Shape1",
            State::Shape0S20 => "20:Shape0",
            State::ShapeS21 => "21:Shape",
            State::SubjectS22 => "22:Subject",
            State::ClassS23 => "23:Class",
            State::OpenTagS24 => "24:OpenTag",
            State::OpenTagS25 => "25:OpenTag",
            State::OpenTagS26 => "26:OpenTag",
            State::OpenTagS27 => "27:OpenTag",
            State::IdentifierS28 => "28:Identifier",
            State::ShapeS29 => "29:Shape",
            State::OpenBraceS30 => "30:OpenBrace",
            State::NamespaceS31 => "31:Namespace",
            State::SubjectIdentifierS32 => "32:SubjectIdentifier",
            State::NamespaceOptS33 => "33:NamespaceOpt",
            State::UriS34 => "34:Uri",
            State::UriS35 => "35:Uri",
            State::PathLiteralS36 => "36:PathLiteral",
            State::PathS37 => "37:Path",
            State::Path1S38 => "38:Path1",
            State::NamespaceS39 => "39:Namespace",
            State::PredicateObject1S40 => "40:PredicateObject1",
            State::PredicateObject0S41 => "41:PredicateObject0",
            State::PredicateObjectS42 => "42:PredicateObject",
            State::PredicateS43 => "43:Predicate",
            State::OpenBracketS44 => "44:OpenBracket",
            State::CloseTagS45 => "45:CloseTag",
            State::CloseTagS46 => "46:CloseTag",
            State::PathS47 => "47:Path",
            State::UnionLiteralS48 => "48:UnionLiteral",
            State::CloseTagS49 => "49:CloseTag",
            State::IdentifierS50 => "50:Identifier",
            State::PredicateObjectS51 => "51:PredicateObject",
            State::CloseBraceS52 => "52:CloseBrace",
            State::AtSignS53 => "53:AtSign",
            State::NamespaceOptS54 => "54:NamespaceOpt",
            State::ObjectS55 => "55:Object",
            State::DataValueS56 => "56:DataValue",
            State::ReferenceS57 => "57:Reference",
            State::ShapePathS58 => "58:ShapePath",
            State::CloseTagS59 => "59:CloseTag",
            State::PathS60 => "60:Path",
            State::DotsS61 => "61:Dots",
            State::OpenBracketS62 => "62:OpenBracket",
            State::SemicolonS63 => "63:Semicolon",
            State::CloseBracketS64 => "64:CloseBracket",
            State::OpenBraceS65 => "65:OpenBrace",
            State::IdentifierS66 => "66:Identifier",
            State::ShapePathS67 => "67:ShapePath",
            State::FieldLiteralS68 => "68:FieldLiteral",
            State::Attribute1S69 => "69:Attribute1",
            State::AttributeS70 => "70:Attribute",
            State::CloseBracketS71 => "71:CloseBracket",
            State::IdentifierS72 => "72:Identifier",
            State::IteratorLiteralS73 => "73:IteratorLiteral",
            State::Nestedterator1S74 => "74:Nestedterator1",
            State::Nestedterator0S75 => "75:Nestedterator0",
            State::NestedteratorS76 => "76:Nestedterator",
            State::AttributeS77 => "77:Attribute",
            State::OpenTagS78 => "78:OpenTag",
            State::IdentifierS79 => "79:Identifier",
            State::NestedteratorS80 => "80:Nestedterator",
            State::CloseBraceS81 => "81:CloseBrace",
            State::PathS82 => "82:Path",
            State::OpenTagS83 => "83:OpenTag",
            State::CloseTagS84 => "84:CloseTag",
            State::PathS85 => "85:Path",
            State::CloseTagS86 => "86:CloseTag",
            State::OpenBraceS87 => "87:OpenBrace",
            State::Attribute1S88 => "88:Attribute1",
            State::IteratorS89 => "89:Iterator",
            State::Iterator1S90 => "90:Iterator1",
            State::Iterator0S91 => "91:Iterator0",
            State::IteratorS92 => "92:Iterator",
            State::CloseBraceS93 => "93:CloseBrace",
        };
        write!(f, "{name}")
    }
}
#[derive(Debug)]
pub enum Symbol {
    Terminal(Terminal),
    NonTerminal(NonTerminal),
}
#[allow(clippy::upper_case_acronyms)]
#[derive(Debug)]
pub enum Terminal {
    PrefixLiteral,
    SourceLiteral,
    IteratorLiteral,
    FieldLiteral,
    ExpressionLiteral,
    UnionLiteral,
    OpenTag,
    CloseTag,
    OpenBrace,
    CloseBrace,
    OpenBracket,
    CloseBracket,
    AtSign,
    Dots,
    Semicolon,
    Namespace(shexml_actions::Namespace),
    Identifier(shexml_actions::Identifier),
    PathLiteral(shexml_actions::PathLiteral),
    Path(shexml_actions::Path),
    ShapePath(shexml_actions::ShapePath),
    Uri(shexml_actions::Uri),
}
#[derive(Debug)]
pub enum NonTerminal {
    Shexml(crate::parser::ast::Shexml),
    Declaration1(shexml_actions::Declaration1),
    Declaration0(shexml_actions::Declaration0),
    Shape1(shexml_actions::Shape1),
    Shape0(shexml_actions::Shape0),
    Declaration(crate::parser::ast::Declaration),
    Prefix(crate::parser::ast::Prefix),
    Source(crate::parser::ast::Source),
    Expression(crate::parser::ast::Expression),
    Path1(shexml_actions::Path1),
    Iterator(crate::parser::ast::Iterator),
    Attribute1(shexml_actions::Attribute1),
    Nestedterator1(shexml_actions::Nestedterator1),
    Nestedterator0(shexml_actions::Nestedterator0),
    Nestedterator(crate::parser::ast::Nestedterator),
    Iterator1(shexml_actions::Iterator1),
    Iterator0(shexml_actions::Iterator0),
    Attribute(crate::parser::ast::Attribute),
    Shape(crate::parser::ast::Shape),
    PredicateObject1(shexml_actions::PredicateObject1),
    PredicateObject0(shexml_actions::PredicateObject0),
    Subject(crate::parser::ast::Subject),
    Class(crate::parser::ast::Class),
    SubjectIdentifier(crate::parser::ast::SubjectIdentifier),
    NamespaceOpt(shexml_actions::NamespaceOpt),
    PredicateObject(crate::parser::ast::PredicateObject),
    Predicate(crate::parser::ast::Predicate),
    Object(crate::parser::ast::Object),
    DataValue(crate::parser::ast::DataValue),
    Reference(crate::parser::ast::Reference),
}
type ActionFn = fn(token: TokenKind) -> Vec<Action<State, ProdKind>>;
pub struct ShexmlParserDefinition {
    actions: [ActionFn; STATE_COUNT],
    gotos: [fn(nonterm: NonTermKind) -> State; STATE_COUNT],
    token_kinds: [[Option<(TokenKind, bool)>; MAX_RECOGNIZERS]; STATE_COUNT],
}
fn action_aug_s0(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::Declaration0P2, 0usize)]),
        TK::PrefixLiteral => Vec::from(&[Shift(State::PrefixLiteralS1)]),
        TK::SourceLiteral => Vec::from(&[Shift(State::SourceLiteralS2)]),
        TK::IteratorLiteral => Vec::from(&[Shift(State::IteratorLiteralS3)]),
        TK::ExpressionLiteral => Vec::from(&[Shift(State::ExpressionLiteralS4)]),
        TK::Namespace => Vec::from(&[Reduce(PK::Declaration0P2, 0usize)]),
        _ => vec![],
    }
}
fn action_prefixliteral_s1(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Namespace => Vec::from(&[Shift(State::NamespaceS13)]),
        _ => vec![],
    }
}
fn action_sourceliteral_s2(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS14)]),
        _ => vec![],
    }
}
fn action_iteratorliteral_s3(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS15)]),
        _ => vec![],
    }
}
fn action_expressionliteral_s4(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS16)]),
        _ => vec![],
    }
}
fn action_shexml_s5(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Accept]),
        _ => vec![],
    }
}
fn action_declaration1_s6(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::Declaration0P1, 1usize)]),
        TK::PrefixLiteral => Vec::from(&[Shift(State::PrefixLiteralS1)]),
        TK::SourceLiteral => Vec::from(&[Shift(State::SourceLiteralS2)]),
        TK::IteratorLiteral => Vec::from(&[Shift(State::IteratorLiteralS3)]),
        TK::ExpressionLiteral => Vec::from(&[Shift(State::ExpressionLiteralS4)]),
        TK::Namespace => Vec::from(&[Reduce(PK::Declaration0P1, 1usize)]),
        _ => vec![],
    }
}
fn action_declaration0_s7(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::Shape0P2, 0usize)]),
        TK::Namespace => Vec::from(&[Shift(State::NamespaceS18)]),
        _ => vec![],
    }
}
fn action_declaration_s8(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::Declaration1P2, 1usize)]),
        TK::PrefixLiteral => Vec::from(&[Reduce(PK::Declaration1P2, 1usize)]),
        TK::SourceLiteral => Vec::from(&[Reduce(PK::Declaration1P2, 1usize)]),
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::Declaration1P2, 1usize)]),
        TK::ExpressionLiteral => Vec::from(&[Reduce(PK::Declaration1P2, 1usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::Declaration1P2, 1usize)]),
        _ => vec![],
    }
}
fn action_prefix_s9(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::DeclarationP1, 1usize)]),
        TK::PrefixLiteral => Vec::from(&[Reduce(PK::DeclarationP1, 1usize)]),
        TK::SourceLiteral => Vec::from(&[Reduce(PK::DeclarationP1, 1usize)]),
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::DeclarationP1, 1usize)]),
        TK::ExpressionLiteral => Vec::from(&[Reduce(PK::DeclarationP1, 1usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::DeclarationP1, 1usize)]),
        _ => vec![],
    }
}
fn action_source_s10(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::DeclarationP2, 1usize)]),
        TK::PrefixLiteral => Vec::from(&[Reduce(PK::DeclarationP2, 1usize)]),
        TK::SourceLiteral => Vec::from(&[Reduce(PK::DeclarationP2, 1usize)]),
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::DeclarationP2, 1usize)]),
        TK::ExpressionLiteral => Vec::from(&[Reduce(PK::DeclarationP2, 1usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::DeclarationP2, 1usize)]),
        _ => vec![],
    }
}
fn action_expression_s11(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::DeclarationP3, 1usize)]),
        TK::PrefixLiteral => Vec::from(&[Reduce(PK::DeclarationP3, 1usize)]),
        TK::SourceLiteral => Vec::from(&[Reduce(PK::DeclarationP3, 1usize)]),
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::DeclarationP3, 1usize)]),
        TK::ExpressionLiteral => Vec::from(&[Reduce(PK::DeclarationP3, 1usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::DeclarationP3, 1usize)]),
        _ => vec![],
    }
}
fn action_iterator_s12(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::DeclarationP4, 1usize)]),
        TK::PrefixLiteral => Vec::from(&[Reduce(PK::DeclarationP4, 1usize)]),
        TK::SourceLiteral => Vec::from(&[Reduce(PK::DeclarationP4, 1usize)]),
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::DeclarationP4, 1usize)]),
        TK::ExpressionLiteral => Vec::from(&[Reduce(PK::DeclarationP4, 1usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::DeclarationP4, 1usize)]),
        _ => vec![],
    }
}
fn action_namespace_s13(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenTag => Vec::from(&[Shift(State::OpenTagS24)]),
        _ => vec![],
    }
}
fn action_identifier_s14(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenTag => Vec::from(&[Shift(State::OpenTagS25)]),
        _ => vec![],
    }
}
fn action_identifier_s15(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenTag => Vec::from(&[Shift(State::OpenTagS26)]),
        _ => vec![],
    }
}
fn action_identifier_s16(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenTag => Vec::from(&[Shift(State::OpenTagS27)]),
        _ => vec![],
    }
}
fn action_declaration_s17(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::Declaration1P1, 2usize)]),
        TK::PrefixLiteral => Vec::from(&[Reduce(PK::Declaration1P1, 2usize)]),
        TK::SourceLiteral => Vec::from(&[Reduce(PK::Declaration1P1, 2usize)]),
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::Declaration1P1, 2usize)]),
        TK::ExpressionLiteral => Vec::from(&[Reduce(PK::Declaration1P1, 2usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::Declaration1P1, 2usize)]),
        _ => vec![],
    }
}
fn action_namespace_s18(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS28)]),
        _ => vec![],
    }
}
fn action_shape1_s19(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::Shape0P1, 1usize)]),
        TK::Namespace => Vec::from(&[Shift(State::NamespaceS18)]),
        _ => vec![],
    }
}
fn action_shape0_s20(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::ShexmlP1, 2usize)]),
        _ => vec![],
    }
}
fn action_shape_s21(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::Shape1P2, 1usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::Shape1P2, 1usize)]),
        _ => vec![],
    }
}
fn action_subject_s22(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenBrace => Vec::from(&[Shift(State::OpenBraceS30)]),
        _ => vec![],
    }
}
fn action_class_s23(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenBracket => Vec::from(&[Reduce(PK::NamespaceOptP2, 0usize)]),
        TK::Namespace => Vec::from(&[Shift(State::NamespaceS31)]),
        _ => vec![],
    }
}
fn action_opentag_s24(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Uri => Vec::from(&[Shift(State::UriS34)]),
        _ => vec![],
    }
}
fn action_opentag_s25(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Uri => Vec::from(&[Shift(State::UriS35)]),
        _ => vec![],
    }
}
fn action_opentag_s26(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::PathLiteral => Vec::from(&[Shift(State::PathLiteralS36)]),
        _ => vec![],
    }
}
fn action_opentag_s27(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Path => Vec::from(&[Shift(State::PathS37)]),
        _ => vec![],
    }
}
fn action_identifier_s28(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenBracket => Vec::from(&[Reduce(PK::ClassP1, 2usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::ClassP1, 2usize)]),
        _ => vec![],
    }
}
fn action_shape_s29(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::Shape1P1, 2usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::Shape1P1, 2usize)]),
        _ => vec![],
    }
}
fn action_openbrace_s30(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::CloseBrace => Vec::from(&[Reduce(PK::PredicateObject0P2, 0usize)]),
        TK::Namespace => Vec::from(&[Shift(State::NamespaceS39)]),
        _ => vec![],
    }
}
fn action_namespace_s31(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenBracket => Vec::from(&[Reduce(PK::NamespaceOptP1, 1usize)]),
        _ => vec![],
    }
}
fn action_subjectidentifier_s32(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenBrace => Vec::from(&[Reduce(PK::SubjectP1, 2usize)]),
        _ => vec![],
    }
}
fn action_namespaceopt_s33(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenBracket => Vec::from(&[Shift(State::OpenBracketS44)]),
        _ => vec![],
    }
}
fn action_uri_s34(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::CloseTag => Vec::from(&[Shift(State::CloseTagS45)]),
        _ => vec![],
    }
}
fn action_uri_s35(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::CloseTag => Vec::from(&[Shift(State::CloseTagS46)]),
        _ => vec![],
    }
}
fn action_pathliteral_s36(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Path => Vec::from(&[Shift(State::PathS47)]),
        _ => vec![],
    }
}
fn action_path_s37(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::UnionLiteral => Vec::from(&[Reduce(PK::Path1P2, 1usize)]),
        TK::CloseTag => Vec::from(&[Reduce(PK::Path1P2, 1usize)]),
        _ => vec![],
    }
}
fn action_path1_s38(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::UnionLiteral => Vec::from(&[Shift(State::UnionLiteralS48)]),
        TK::CloseTag => Vec::from(&[Shift(State::CloseTagS49)]),
        _ => vec![],
    }
}
fn action_namespace_s39(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS50)]),
        _ => vec![],
    }
}
fn action_predicateobject1_s40(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::CloseBrace => Vec::from(&[Reduce(PK::PredicateObject0P1, 1usize)]),
        TK::Namespace => Vec::from(&[Shift(State::NamespaceS39)]),
        _ => vec![],
    }
}
fn action_predicateobject0_s41(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::CloseBrace => Vec::from(&[Shift(State::CloseBraceS52)]),
        _ => vec![],
    }
}
fn action_predicateobject_s42(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::CloseBrace => Vec::from(&[Reduce(PK::PredicateObject1P2, 1usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::PredicateObject1P2, 1usize)]),
        _ => vec![],
    }
}
fn action_predicate_s43(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenBracket => Vec::from(&[Reduce(PK::NamespaceOptP2, 0usize)]),
        TK::AtSign => Vec::from(&[Shift(State::AtSignS53)]),
        TK::Namespace => Vec::from(&[Shift(State::NamespaceS31)]),
        _ => vec![],
    }
}
fn action_openbracket_s44(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::ShapePath => Vec::from(&[Shift(State::ShapePathS58)]),
        _ => vec![],
    }
}
fn action_closetag_s45(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::PrefixP1, 5usize)]),
        TK::PrefixLiteral => Vec::from(&[Reduce(PK::PrefixP1, 5usize)]),
        TK::SourceLiteral => Vec::from(&[Reduce(PK::PrefixP1, 5usize)]),
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::PrefixP1, 5usize)]),
        TK::ExpressionLiteral => Vec::from(&[Reduce(PK::PrefixP1, 5usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::PrefixP1, 5usize)]),
        _ => vec![],
    }
}
fn action_closetag_s46(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::SourceP1, 5usize)]),
        TK::PrefixLiteral => Vec::from(&[Reduce(PK::SourceP1, 5usize)]),
        TK::SourceLiteral => Vec::from(&[Reduce(PK::SourceP1, 5usize)]),
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::SourceP1, 5usize)]),
        TK::ExpressionLiteral => Vec::from(&[Reduce(PK::SourceP1, 5usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::SourceP1, 5usize)]),
        _ => vec![],
    }
}
fn action_path_s47(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::CloseTag => Vec::from(&[Shift(State::CloseTagS59)]),
        _ => vec![],
    }
}
fn action_unionliteral_s48(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Path => Vec::from(&[Shift(State::PathS60)]),
        _ => vec![],
    }
}
fn action_closetag_s49(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::ExpressionP1, 5usize)]),
        TK::PrefixLiteral => Vec::from(&[Reduce(PK::ExpressionP1, 5usize)]),
        TK::SourceLiteral => Vec::from(&[Reduce(PK::ExpressionP1, 5usize)]),
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::ExpressionP1, 5usize)]),
        TK::ExpressionLiteral => Vec::from(&[Reduce(PK::ExpressionP1, 5usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::ExpressionP1, 5usize)]),
        _ => vec![],
    }
}
fn action_identifier_s50(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenBracket => Vec::from(&[Reduce(PK::PredicateP1, 2usize)]),
        TK::AtSign => Vec::from(&[Reduce(PK::PredicateP1, 2usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::PredicateP1, 2usize)]),
        _ => vec![],
    }
}
fn action_predicateobject_s51(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::CloseBrace => Vec::from(&[Reduce(PK::PredicateObject1P1, 2usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::PredicateObject1P1, 2usize)]),
        _ => vec![],
    }
}
fn action_closebrace_s52(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::ShapeP1, 4usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::ShapeP1, 4usize)]),
        _ => vec![],
    }
}
fn action_atsign_s53(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Dots => Vec::from(&[Shift(State::DotsS61)]),
        _ => vec![],
    }
}
fn action_namespaceopt_s54(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenBracket => Vec::from(&[Shift(State::OpenBracketS62)]),
        _ => vec![],
    }
}
fn action_object_s55(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Semicolon => Vec::from(&[Shift(State::SemicolonS63)]),
        _ => vec![],
    }
}
fn action_datavalue_s56(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Semicolon => Vec::from(&[Reduce(PK::ObjectP1, 1usize)]),
        _ => vec![],
    }
}
fn action_reference_s57(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Semicolon => Vec::from(&[Reduce(PK::ObjectP2, 1usize)]),
        _ => vec![],
    }
}
fn action_shapepath_s58(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::CloseBracket => Vec::from(&[Shift(State::CloseBracketS64)]),
        _ => vec![],
    }
}
fn action_closetag_s59(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenBrace => Vec::from(&[Shift(State::OpenBraceS65)]),
        _ => vec![],
    }
}
fn action_path_s60(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::UnionLiteral => Vec::from(&[Reduce(PK::Path1P1, 3usize)]),
        TK::CloseTag => Vec::from(&[Reduce(PK::Path1P1, 3usize)]),
        _ => vec![],
    }
}
fn action_dots_s61(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS66)]),
        _ => vec![],
    }
}
fn action_openbracket_s62(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::ShapePath => Vec::from(&[Shift(State::ShapePathS67)]),
        _ => vec![],
    }
}
fn action_semicolon_s63(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::CloseBrace => Vec::from(&[Reduce(PK::PredicateObjectP1, 3usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::PredicateObjectP1, 3usize)]),
        _ => vec![],
    }
}
fn action_closebracket_s64(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenBrace => Vec::from(&[Reduce(PK::SubjectIdentifierP1, 4usize)]),
        _ => vec![],
    }
}
fn action_openbrace_s65(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::FieldLiteral => Vec::from(&[Shift(State::FieldLiteralS68)]),
        _ => vec![],
    }
}
fn action_identifier_s66(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Semicolon => Vec::from(&[Reduce(PK::ReferenceP1, 3usize)]),
        _ => vec![],
    }
}
fn action_shapepath_s67(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::CloseBracket => Vec::from(&[Shift(State::CloseBracketS71)]),
        _ => vec![],
    }
}
fn action_fieldliteral_s68(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS72)]),
        _ => vec![],
    }
}
fn action_attribute1_s69(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::IteratorLiteral => Vec::from(&[Shift(State::IteratorLiteralS73)]),
        TK::FieldLiteral => Vec::from(&[Shift(State::FieldLiteralS68)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::Nestedterator0P2, 0usize)]),
        _ => vec![],
    }
}
fn action_attribute_s70(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::Attribute1P2, 1usize)]),
        TK::FieldLiteral => Vec::from(&[Reduce(PK::Attribute1P2, 1usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::Attribute1P2, 1usize)]),
        _ => vec![],
    }
}
fn action_closebracket_s71(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Semicolon => Vec::from(&[Reduce(PK::DataValueP1, 4usize)]),
        _ => vec![],
    }
}
fn action_identifier_s72(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenTag => Vec::from(&[Shift(State::OpenTagS78)]),
        _ => vec![],
    }
}
fn action_iteratorliteral_s73(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS79)]),
        _ => vec![],
    }
}
fn action_nestedterator1_s74(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::IteratorLiteral => Vec::from(&[Shift(State::IteratorLiteralS73)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::Nestedterator0P1, 1usize)]),
        _ => vec![],
    }
}
fn action_nestedterator0_s75(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::CloseBrace => Vec::from(&[Shift(State::CloseBraceS81)]),
        _ => vec![],
    }
}
fn action_nestedterator_s76(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::Nestedterator1P2, 1usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::Nestedterator1P2, 1usize)]),
        _ => vec![],
    }
}
fn action_attribute_s77(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::Attribute1P1, 2usize)]),
        TK::FieldLiteral => Vec::from(&[Reduce(PK::Attribute1P1, 2usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::Attribute1P1, 2usize)]),
        _ => vec![],
    }
}
fn action_opentag_s78(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Path => Vec::from(&[Shift(State::PathS82)]),
        _ => vec![],
    }
}
fn action_identifier_s79(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenTag => Vec::from(&[Shift(State::OpenTagS83)]),
        _ => vec![],
    }
}
fn action_nestedterator_s80(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::Nestedterator1P1, 2usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::Nestedterator1P1, 2usize)]),
        _ => vec![],
    }
}
fn action_closebrace_s81(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::IteratorP1, 10usize)]),
        TK::PrefixLiteral => Vec::from(&[Reduce(PK::IteratorP1, 10usize)]),
        TK::SourceLiteral => Vec::from(&[Reduce(PK::IteratorP1, 10usize)]),
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::IteratorP1, 10usize)]),
        TK::ExpressionLiteral => Vec::from(&[Reduce(PK::IteratorP1, 10usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::IteratorP1, 10usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::IteratorP1, 10usize)]),
        _ => vec![],
    }
}
fn action_path_s82(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::CloseTag => Vec::from(&[Shift(State::CloseTagS84)]),
        _ => vec![],
    }
}
fn action_opentag_s83(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Path => Vec::from(&[Shift(State::PathS85)]),
        _ => vec![],
    }
}
fn action_closetag_s84(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::AttributeP1, 5usize)]),
        TK::FieldLiteral => Vec::from(&[Reduce(PK::AttributeP1, 5usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::AttributeP1, 5usize)]),
        _ => vec![],
    }
}
fn action_path_s85(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::CloseTag => Vec::from(&[Shift(State::CloseTagS86)]),
        _ => vec![],
    }
}
fn action_closetag_s86(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenBrace => Vec::from(&[Shift(State::OpenBraceS87)]),
        _ => vec![],
    }
}
fn action_openbrace_s87(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::FieldLiteral => Vec::from(&[Shift(State::FieldLiteralS68)]),
        _ => vec![],
    }
}
fn action_attribute1_s88(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::IteratorLiteral => Vec::from(&[Shift(State::IteratorLiteralS3)]),
        TK::FieldLiteral => Vec::from(&[Shift(State::FieldLiteralS68)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::Iterator0P2, 0usize)]),
        _ => vec![],
    }
}
fn action_iterator_s89(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::Iterator1P2, 1usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::Iterator1P2, 1usize)]),
        _ => vec![],
    }
}
fn action_iterator1_s90(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::IteratorLiteral => Vec::from(&[Shift(State::IteratorLiteralS3)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::Iterator0P1, 1usize)]),
        _ => vec![],
    }
}
fn action_iterator0_s91(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::CloseBrace => Vec::from(&[Shift(State::CloseBraceS93)]),
        _ => vec![],
    }
}
fn action_iterator_s92(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::Iterator1P1, 2usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::Iterator1P1, 2usize)]),
        _ => vec![],
    }
}
fn action_closebrace_s93(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::NestedteratorP1, 9usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::NestedteratorP1, 9usize)]),
        _ => vec![],
    }
}
fn goto_aug_s0(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Shexml => State::ShexmlS5,
        NonTermKind::Declaration1 => State::Declaration1S6,
        NonTermKind::Declaration0 => State::Declaration0S7,
        NonTermKind::Declaration => State::DeclarationS8,
        NonTermKind::Prefix => State::PrefixS9,
        NonTermKind::Source => State::SourceS10,
        NonTermKind::Expression => State::ExpressionS11,
        NonTermKind::Iterator => State::IteratorS12,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::AUGS0
            )
        }
    }
}
fn goto_declaration1_s6(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Declaration => State::DeclarationS17,
        NonTermKind::Prefix => State::PrefixS9,
        NonTermKind::Source => State::SourceS10,
        NonTermKind::Expression => State::ExpressionS11,
        NonTermKind::Iterator => State::IteratorS12,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::Declaration1S6
            )
        }
    }
}
fn goto_declaration0_s7(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Shape1 => State::Shape1S19,
        NonTermKind::Shape0 => State::Shape0S20,
        NonTermKind::Shape => State::ShapeS21,
        NonTermKind::Subject => State::SubjectS22,
        NonTermKind::Class => State::ClassS23,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::Declaration0S7
            )
        }
    }
}
fn goto_shape1_s19(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Shape => State::ShapeS29,
        NonTermKind::Subject => State::SubjectS22,
        NonTermKind::Class => State::ClassS23,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::Shape1S19
            )
        }
    }
}
fn goto_class_s23(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::SubjectIdentifier => State::SubjectIdentifierS32,
        NonTermKind::NamespaceOpt => State::NamespaceOptS33,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::ClassS23
            )
        }
    }
}
fn goto_opentag_s27(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Path1 => State::Path1S38,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::OpenTagS27
            )
        }
    }
}
fn goto_openbrace_s30(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::PredicateObject1 => State::PredicateObject1S40,
        NonTermKind::PredicateObject0 => State::PredicateObject0S41,
        NonTermKind::PredicateObject => State::PredicateObjectS42,
        NonTermKind::Predicate => State::PredicateS43,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::OpenBraceS30
            )
        }
    }
}
fn goto_predicateobject1_s40(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::PredicateObject => State::PredicateObjectS51,
        NonTermKind::Predicate => State::PredicateS43,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::PredicateObject1S40
            )
        }
    }
}
fn goto_predicate_s43(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::NamespaceOpt => State::NamespaceOptS54,
        NonTermKind::Object => State::ObjectS55,
        NonTermKind::DataValue => State::DataValueS56,
        NonTermKind::Reference => State::ReferenceS57,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::PredicateS43
            )
        }
    }
}
fn goto_openbrace_s65(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Attribute1 => State::Attribute1S69,
        NonTermKind::Attribute => State::AttributeS70,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::OpenBraceS65
            )
        }
    }
}
fn goto_attribute1_s69(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Nestedterator1 => State::Nestedterator1S74,
        NonTermKind::Nestedterator0 => State::Nestedterator0S75,
        NonTermKind::Nestedterator => State::NestedteratorS76,
        NonTermKind::Attribute => State::AttributeS77,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::Attribute1S69
            )
        }
    }
}
fn goto_nestedterator1_s74(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Nestedterator => State::NestedteratorS80,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::Nestedterator1S74
            )
        }
    }
}
fn goto_openbrace_s87(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Attribute1 => State::Attribute1S88,
        NonTermKind::Attribute => State::AttributeS70,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::OpenBraceS87
            )
        }
    }
}
fn goto_attribute1_s88(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Iterator => State::IteratorS89,
        NonTermKind::Iterator1 => State::Iterator1S90,
        NonTermKind::Iterator0 => State::Iterator0S91,
        NonTermKind::Attribute => State::AttributeS77,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::Attribute1S88
            )
        }
    }
}
fn goto_iterator1_s90(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Iterator => State::IteratorS92,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::Iterator1S90
            )
        }
    }
}
fn goto_invalid(_nonterm_kind: NonTermKind) -> State {
    panic!("Invalid GOTO entry!");
}
pub(crate) static PARSER_DEFINITION: ShexmlParserDefinition = ShexmlParserDefinition {
    actions: [
        action_aug_s0,
        action_prefixliteral_s1,
        action_sourceliteral_s2,
        action_iteratorliteral_s3,
        action_expressionliteral_s4,
        action_shexml_s5,
        action_declaration1_s6,
        action_declaration0_s7,
        action_declaration_s8,
        action_prefix_s9,
        action_source_s10,
        action_expression_s11,
        action_iterator_s12,
        action_namespace_s13,
        action_identifier_s14,
        action_identifier_s15,
        action_identifier_s16,
        action_declaration_s17,
        action_namespace_s18,
        action_shape1_s19,
        action_shape0_s20,
        action_shape_s21,
        action_subject_s22,
        action_class_s23,
        action_opentag_s24,
        action_opentag_s25,
        action_opentag_s26,
        action_opentag_s27,
        action_identifier_s28,
        action_shape_s29,
        action_openbrace_s30,
        action_namespace_s31,
        action_subjectidentifier_s32,
        action_namespaceopt_s33,
        action_uri_s34,
        action_uri_s35,
        action_pathliteral_s36,
        action_path_s37,
        action_path1_s38,
        action_namespace_s39,
        action_predicateobject1_s40,
        action_predicateobject0_s41,
        action_predicateobject_s42,
        action_predicate_s43,
        action_openbracket_s44,
        action_closetag_s45,
        action_closetag_s46,
        action_path_s47,
        action_unionliteral_s48,
        action_closetag_s49,
        action_identifier_s50,
        action_predicateobject_s51,
        action_closebrace_s52,
        action_atsign_s53,
        action_namespaceopt_s54,
        action_object_s55,
        action_datavalue_s56,
        action_reference_s57,
        action_shapepath_s58,
        action_closetag_s59,
        action_path_s60,
        action_dots_s61,
        action_openbracket_s62,
        action_semicolon_s63,
        action_closebracket_s64,
        action_openbrace_s65,
        action_identifier_s66,
        action_shapepath_s67,
        action_fieldliteral_s68,
        action_attribute1_s69,
        action_attribute_s70,
        action_closebracket_s71,
        action_identifier_s72,
        action_iteratorliteral_s73,
        action_nestedterator1_s74,
        action_nestedterator0_s75,
        action_nestedterator_s76,
        action_attribute_s77,
        action_opentag_s78,
        action_identifier_s79,
        action_nestedterator_s80,
        action_closebrace_s81,
        action_path_s82,
        action_opentag_s83,
        action_closetag_s84,
        action_path_s85,
        action_closetag_s86,
        action_openbrace_s87,
        action_attribute1_s88,
        action_iterator_s89,
        action_iterator1_s90,
        action_iterator0_s91,
        action_iterator_s92,
        action_closebrace_s93,
    ],
    gotos: [
        goto_aug_s0,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_declaration1_s6,
        goto_declaration0_s7,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_shape1_s19,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_class_s23,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_opentag_s27,
        goto_invalid,
        goto_invalid,
        goto_openbrace_s30,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_predicateobject1_s40,
        goto_invalid,
        goto_invalid,
        goto_predicate_s43,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_openbrace_s65,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_attribute1_s69,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_nestedterator1_s74,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_openbrace_s87,
        goto_attribute1_s88,
        goto_invalid,
        goto_iterator1_s90,
        goto_invalid,
        goto_invalid,
        goto_invalid,
    ],
    token_kinds: [
        [
            Some((TK::STOP, true)),
            Some((TK::ExpressionLiteral, true)),
            Some((TK::IteratorLiteral, true)),
            Some((TK::PrefixLiteral, true)),
            Some((TK::SourceLiteral, true)),
            Some((TK::Namespace, false)),
            None,
        ],
        [Some((TK::Namespace, false)), None, None, None, None, None, None],
        [Some((TK::Identifier, false)), None, None, None, None, None, None],
        [Some((TK::Identifier, false)), None, None, None, None, None, None],
        [Some((TK::Identifier, false)), None, None, None, None, None, None],
        [Some((TK::STOP, false)), None, None, None, None, None, None],
        [
            Some((TK::STOP, true)),
            Some((TK::ExpressionLiteral, true)),
            Some((TK::IteratorLiteral, true)),
            Some((TK::PrefixLiteral, true)),
            Some((TK::SourceLiteral, true)),
            Some((TK::Namespace, false)),
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::Namespace, false)),
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::ExpressionLiteral, true)),
            Some((TK::IteratorLiteral, true)),
            Some((TK::PrefixLiteral, true)),
            Some((TK::SourceLiteral, true)),
            Some((TK::Namespace, false)),
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::ExpressionLiteral, true)),
            Some((TK::IteratorLiteral, true)),
            Some((TK::PrefixLiteral, true)),
            Some((TK::SourceLiteral, true)),
            Some((TK::Namespace, false)),
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::ExpressionLiteral, true)),
            Some((TK::IteratorLiteral, true)),
            Some((TK::PrefixLiteral, true)),
            Some((TK::SourceLiteral, true)),
            Some((TK::Namespace, false)),
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::ExpressionLiteral, true)),
            Some((TK::IteratorLiteral, true)),
            Some((TK::PrefixLiteral, true)),
            Some((TK::SourceLiteral, true)),
            Some((TK::Namespace, false)),
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::ExpressionLiteral, true)),
            Some((TK::IteratorLiteral, true)),
            Some((TK::PrefixLiteral, true)),
            Some((TK::SourceLiteral, true)),
            Some((TK::Namespace, false)),
            None,
        ],
        [Some((TK::OpenTag, true)), None, None, None, None, None, None],
        [Some((TK::OpenTag, true)), None, None, None, None, None, None],
        [Some((TK::OpenTag, true)), None, None, None, None, None, None],
        [Some((TK::OpenTag, true)), None, None, None, None, None, None],
        [
            Some((TK::STOP, true)),
            Some((TK::ExpressionLiteral, true)),
            Some((TK::IteratorLiteral, true)),
            Some((TK::PrefixLiteral, true)),
            Some((TK::SourceLiteral, true)),
            Some((TK::Namespace, false)),
            None,
        ],
        [Some((TK::Identifier, false)), None, None, None, None, None, None],
        [
            Some((TK::STOP, true)),
            Some((TK::Namespace, false)),
            None,
            None,
            None,
            None,
            None,
        ],
        [Some((TK::STOP, false)), None, None, None, None, None, None],
        [
            Some((TK::STOP, true)),
            Some((TK::Namespace, false)),
            None,
            None,
            None,
            None,
            None,
        ],
        [Some((TK::OpenBrace, true)), None, None, None, None, None, None],
        [
            Some((TK::OpenBracket, true)),
            Some((TK::Namespace, false)),
            None,
            None,
            None,
            None,
            None,
        ],
        [Some((TK::Uri, false)), None, None, None, None, None, None],
        [Some((TK::Uri, false)), None, None, None, None, None, None],
        [Some((TK::PathLiteral, false)), None, None, None, None, None, None],
        [Some((TK::Path, false)), None, None, None, None, None, None],
        [
            Some((TK::OpenBracket, true)),
            Some((TK::Namespace, false)),
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::Namespace, false)),
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::CloseBrace, true)),
            Some((TK::Namespace, false)),
            None,
            None,
            None,
            None,
            None,
        ],
        [Some((TK::OpenBracket, true)), None, None, None, None, None, None],
        [Some((TK::OpenBrace, true)), None, None, None, None, None, None],
        [Some((TK::OpenBracket, true)), None, None, None, None, None, None],
        [Some((TK::CloseTag, true)), None, None, None, None, None, None],
        [Some((TK::CloseTag, true)), None, None, None, None, None, None],
        [Some((TK::Path, false)), None, None, None, None, None, None],
        [
            Some((TK::UnionLiteral, true)),
            Some((TK::CloseTag, true)),
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::UnionLiteral, true)),
            Some((TK::CloseTag, true)),
            None,
            None,
            None,
            None,
            None,
        ],
        [Some((TK::Identifier, false)), None, None, None, None, None, None],
        [
            Some((TK::CloseBrace, true)),
            Some((TK::Namespace, false)),
            None,
            None,
            None,
            None,
            None,
        ],
        [Some((TK::CloseBrace, true)), None, None, None, None, None, None],
        [
            Some((TK::CloseBrace, true)),
            Some((TK::Namespace, false)),
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::OpenBracket, true)),
            Some((TK::AtSign, true)),
            Some((TK::Namespace, false)),
            None,
            None,
            None,
            None,
        ],
        [Some((TK::ShapePath, false)), None, None, None, None, None, None],
        [
            Some((TK::STOP, true)),
            Some((TK::ExpressionLiteral, true)),
            Some((TK::IteratorLiteral, true)),
            Some((TK::PrefixLiteral, true)),
            Some((TK::SourceLiteral, true)),
            Some((TK::Namespace, false)),
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::ExpressionLiteral, true)),
            Some((TK::IteratorLiteral, true)),
            Some((TK::PrefixLiteral, true)),
            Some((TK::SourceLiteral, true)),
            Some((TK::Namespace, false)),
            None,
        ],
        [Some((TK::CloseTag, true)), None, None, None, None, None, None],
        [Some((TK::Path, false)), None, None, None, None, None, None],
        [
            Some((TK::STOP, true)),
            Some((TK::ExpressionLiteral, true)),
            Some((TK::IteratorLiteral, true)),
            Some((TK::PrefixLiteral, true)),
            Some((TK::SourceLiteral, true)),
            Some((TK::Namespace, false)),
            None,
        ],
        [
            Some((TK::OpenBracket, true)),
            Some((TK::AtSign, true)),
            Some((TK::Namespace, false)),
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::CloseBrace, true)),
            Some((TK::Namespace, false)),
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::Namespace, false)),
            None,
            None,
            None,
            None,
            None,
        ],
        [Some((TK::Dots, true)), None, None, None, None, None, None],
        [Some((TK::OpenBracket, true)), None, None, None, None, None, None],
        [Some((TK::Semicolon, true)), None, None, None, None, None, None],
        [Some((TK::Semicolon, true)), None, None, None, None, None, None],
        [Some((TK::Semicolon, true)), None, None, None, None, None, None],
        [Some((TK::CloseBracket, true)), None, None, None, None, None, None],
        [Some((TK::OpenBrace, true)), None, None, None, None, None, None],
        [
            Some((TK::UnionLiteral, true)),
            Some((TK::CloseTag, true)),
            None,
            None,
            None,
            None,
            None,
        ],
        [Some((TK::Identifier, false)), None, None, None, None, None, None],
        [Some((TK::ShapePath, false)), None, None, None, None, None, None],
        [
            Some((TK::CloseBrace, true)),
            Some((TK::Namespace, false)),
            None,
            None,
            None,
            None,
            None,
        ],
        [Some((TK::OpenBrace, true)), None, None, None, None, None, None],
        [Some((TK::FieldLiteral, true)), None, None, None, None, None, None],
        [Some((TK::Semicolon, true)), None, None, None, None, None, None],
        [Some((TK::CloseBracket, true)), None, None, None, None, None, None],
        [Some((TK::Identifier, false)), None, None, None, None, None, None],
        [
            Some((TK::IteratorLiteral, true)),
            Some((TK::FieldLiteral, true)),
            Some((TK::CloseBrace, true)),
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::IteratorLiteral, true)),
            Some((TK::FieldLiteral, true)),
            Some((TK::CloseBrace, true)),
            None,
            None,
            None,
            None,
        ],
        [Some((TK::Semicolon, true)), None, None, None, None, None, None],
        [Some((TK::OpenTag, true)), None, None, None, None, None, None],
        [Some((TK::Identifier, false)), None, None, None, None, None, None],
        [
            Some((TK::IteratorLiteral, true)),
            Some((TK::CloseBrace, true)),
            None,
            None,
            None,
            None,
            None,
        ],
        [Some((TK::CloseBrace, true)), None, None, None, None, None, None],
        [
            Some((TK::IteratorLiteral, true)),
            Some((TK::CloseBrace, true)),
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::IteratorLiteral, true)),
            Some((TK::FieldLiteral, true)),
            Some((TK::CloseBrace, true)),
            None,
            None,
            None,
            None,
        ],
        [Some((TK::Path, false)), None, None, None, None, None, None],
        [Some((TK::OpenTag, true)), None, None, None, None, None, None],
        [
            Some((TK::IteratorLiteral, true)),
            Some((TK::CloseBrace, true)),
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::ExpressionLiteral, true)),
            Some((TK::IteratorLiteral, true)),
            Some((TK::PrefixLiteral, true)),
            Some((TK::SourceLiteral, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Namespace, false)),
        ],
        [Some((TK::CloseTag, true)), None, None, None, None, None, None],
        [Some((TK::Path, false)), None, None, None, None, None, None],
        [
            Some((TK::IteratorLiteral, true)),
            Some((TK::FieldLiteral, true)),
            Some((TK::CloseBrace, true)),
            None,
            None,
            None,
            None,
        ],
        [Some((TK::CloseTag, true)), None, None, None, None, None, None],
        [Some((TK::OpenBrace, true)), None, None, None, None, None, None],
        [Some((TK::FieldLiteral, true)), None, None, None, None, None, None],
        [
            Some((TK::IteratorLiteral, true)),
            Some((TK::FieldLiteral, true)),
            Some((TK::CloseBrace, true)),
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::IteratorLiteral, true)),
            Some((TK::CloseBrace, true)),
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::IteratorLiteral, true)),
            Some((TK::CloseBrace, true)),
            None,
            None,
            None,
            None,
            None,
        ],
        [Some((TK::CloseBrace, true)), None, None, None, None, None, None],
        [
            Some((TK::IteratorLiteral, true)),
            Some((TK::CloseBrace, true)),
            None,
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::IteratorLiteral, true)),
            Some((TK::CloseBrace, true)),
            None,
            None,
            None,
            None,
            None,
        ],
    ],
};
impl ParserDefinition<State, ProdKind, TokenKind, NonTermKind>
for ShexmlParserDefinition {
    fn actions(&self, state: State, token: TokenKind) -> Vec<Action<State, ProdKind>> {
        PARSER_DEFINITION.actions[state as usize](token)
    }
    fn goto(&self, state: State, nonterm: NonTermKind) -> State {
        PARSER_DEFINITION.gotos[state as usize](nonterm)
    }
    fn expected_token_kinds(&self, state: State) -> Vec<(TokenKind, bool)> {
        PARSER_DEFINITION.token_kinds[state as usize].iter().map_while(|t| *t).collect()
    }
    fn longest_match() -> bool {
        true
    }
    fn grammar_order() -> bool {
        true
    }
}
pub(crate) type Context<'i, I> = LRContext<'i, I, State, TokenKind>;
pub struct ShexmlParser<
    'i,
    I: InputT + ?Sized,
    L: Lexer<'i, Context<'i, I>, State, TokenKind, Input = I>,
    B,
>(
    LRParser<
        'i,
        Context<'i, I>,
        State,
        ProdKind,
        TokenKind,
        NonTermKind,
        ShexmlParserDefinition,
        L,
        B,
        I,
    >,
);
#[allow(dead_code)]
impl<
    'i,
> ShexmlParser<
    'i,
    Input,
    StringLexer<Context<'i, Input>, State, TokenKind, TokenRecognizer, TERMINAL_COUNT>,
    DefaultBuilder,
> {
    pub fn new() -> Self {
        Self(
            LRParser::new(
                &PARSER_DEFINITION,
                State::default(),
                false,
                false,
                StringLexer::new(true, &RECOGNIZERS),
                DefaultBuilder::new(),
            ),
        )
    }
}
#[allow(dead_code)]
impl<'i, I, L, B> Parser<'i, I, Context<'i, I>, State, TokenKind>
for ShexmlParser<'i, I, L, B>
where
    I: InputT + ?Sized + Debug,
    L: Lexer<'i, Context<'i, I>, State, TokenKind, Input = I>,
    B: LRBuilder<'i, I, Context<'i, I>, State, ProdKind, TokenKind>,
{
    type Output = B::Output;
    fn parse(&self, input: &'i I) -> Result<Self::Output> {
        self.0.parse(input)
    }
    fn parse_with_context(
        &self,
        context: &mut Context<'i, I>,
        input: &'i I,
    ) -> Result<Self::Output> {
        self.0.parse_with_context(context, input)
    }
    fn parse_file<'a, F: AsRef<std::path::Path>>(
        &'a mut self,
        file: F,
    ) -> Result<Self::Output>
    where
        'a: 'i,
    {
        self.0.parse_file(file)
    }
}
#[allow(dead_code)]
#[derive(Debug)]
pub enum Recognizer {
    Stop,
    StrMatch(&'static str),
    RegexMatch(Lazy<Regex>),
}
#[allow(dead_code)]
#[derive(Debug)]
pub struct TokenRecognizer(TokenKind, Recognizer);
impl<'i> TokenRecognizerT<'i> for TokenRecognizer {
    fn recognize(&self, input: &'i str) -> Option<&'i str> {
        match &self {
            #[allow(unused_variables)]
            TokenRecognizer(token_kind, Recognizer::StrMatch(s)) => {
                logn!("{} {:?} -- ", "    Recognizing".green(), token_kind);
                if input.starts_with(s) {
                    log!("{}", "recognized".bold().green());
                    Some(s)
                } else {
                    log!("{}", "not recognized".red());
                    None
                }
            }
            #[allow(unused_variables)]
            TokenRecognizer(token_kind, Recognizer::RegexMatch(r)) => {
                logn!("{} {:?} -- ", "    Recognizing".green(), token_kind);
                let match_str = r.find(input);
                match match_str {
                    Some(x) => {
                        let x_str = x.as_str();
                        log!("{} '{}'", "recognized".bold().green(), x_str);
                        Some(x_str)
                    }
                    _ => {
                        log!("{}", "not recognized".red());
                        None
                    }
                }
            }
            TokenRecognizer(_, Recognizer::Stop) => {
                logn!("{} STOP -- ", "    Recognizing".green());
                if input.is_empty() {
                    log!("{}", "recognized".bold().green());
                    Some("")
                } else {
                    log!("{}", "not recognized".red());
                    None
                }
            }
        }
    }
}
pub(crate) static RECOGNIZERS: [TokenRecognizer; TERMINAL_COUNT] = [
    TokenRecognizer(TokenKind::STOP, Recognizer::Stop),
    TokenRecognizer(TokenKind::PrefixLiteral, Recognizer::StrMatch("PREFIX")),
    TokenRecognizer(TokenKind::SourceLiteral, Recognizer::StrMatch("SOURCE")),
    TokenRecognizer(TokenKind::IteratorLiteral, Recognizer::StrMatch("ITERATOR")),
    TokenRecognizer(TokenKind::FieldLiteral, Recognizer::StrMatch("FIELD")),
    TokenRecognizer(TokenKind::ExpressionLiteral, Recognizer::StrMatch("EXPRESSION")),
    TokenRecognizer(TokenKind::UnionLiteral, Recognizer::StrMatch("UNION")),
    TokenRecognizer(TokenKind::OpenTag, Recognizer::StrMatch("<")),
    TokenRecognizer(TokenKind::CloseTag, Recognizer::StrMatch(">")),
    TokenRecognizer(TokenKind::OpenBrace, Recognizer::StrMatch("{")),
    TokenRecognizer(TokenKind::CloseBrace, Recognizer::StrMatch("}")),
    TokenRecognizer(TokenKind::OpenBracket, Recognizer::StrMatch("[")),
    TokenRecognizer(TokenKind::CloseBracket, Recognizer::StrMatch("]")),
    TokenRecognizer(TokenKind::AtSign, Recognizer::StrMatch("@")),
    TokenRecognizer(TokenKind::Dots, Recognizer::StrMatch(":")),
    TokenRecognizer(TokenKind::Semicolon, Recognizer::StrMatch(";")),
    TokenRecognizer(
        TokenKind::Namespace,
        Recognizer::RegexMatch(
            Lazy::new(|| { Regex::new(concat!("^", "[a-zA-Z0-9\\-_]*:")).unwrap() }),
        ),
    ),
    TokenRecognizer(
        TokenKind::Identifier,
        Recognizer::RegexMatch(
            Lazy::new(|| { Regex::new(concat!("^", "[a-zA-Z0-9\\-_]*")).unwrap() }),
        ),
    ),
    TokenRecognizer(
        TokenKind::PathLiteral,
        Recognizer::RegexMatch(
            Lazy::new(|| { Regex::new(concat!("^", "xpath:|jsonpath:")).unwrap() }),
        ),
    ),
    TokenRecognizer(
        TokenKind::Path,
        Recognizer::RegexMatch(
            Lazy::new(|| {
                Regex::new(concat!("^", "[/.@\\$\\[\\]a-zA-Z0-9_\\*\\-'\"]+")).unwrap()
            }),
        ),
    ),
    TokenRecognizer(
        TokenKind::ShapePath,
        Recognizer::RegexMatch(
            Lazy::new(|| { Regex::new(concat!("^", "[/.a-zA-Z0-9_\\*\\-]+")).unwrap() }),
        ),
    ),
    TokenRecognizer(
        TokenKind::Uri,
        Recognizer::RegexMatch(
            Lazy::new(|| { Regex::new(concat!("^", "https?://[^\\s<>\"]+")).unwrap() }),
        ),
    ),
];
pub struct DefaultBuilder {
    res_stack: Vec<Symbol>,
}
impl DefaultBuilder {
    #[allow(dead_code)]
    pub fn new() -> Self {
        Self { res_stack: vec![] }
    }
}
impl Builder for DefaultBuilder {
    type Output = crate::parser::ast::Shexml;
    fn get_result(&mut self) -> Self::Output {
        match self.res_stack.pop().unwrap() {
            Symbol::NonTerminal(NonTerminal::Shexml(r)) => r,
            _ => panic!("Invalid result on the parse stack!"),
        }
    }
}
impl<'i> LRBuilder<'i, Input, Context<'i, Input>, State, ProdKind, TokenKind>
for DefaultBuilder {
    #![allow(unused_variables)]
    fn shift_action(
        &mut self,
        context: &Context<'i, Input>,
        token: Token<'i, Input, TokenKind>,
    ) {
        let val = match token.kind {
            TokenKind::STOP => panic!("Cannot shift STOP token!"),
            TokenKind::PrefixLiteral => Terminal::PrefixLiteral,
            TokenKind::SourceLiteral => Terminal::SourceLiteral,
            TokenKind::IteratorLiteral => Terminal::IteratorLiteral,
            TokenKind::FieldLiteral => Terminal::FieldLiteral,
            TokenKind::ExpressionLiteral => Terminal::ExpressionLiteral,
            TokenKind::UnionLiteral => Terminal::UnionLiteral,
            TokenKind::OpenTag => Terminal::OpenTag,
            TokenKind::CloseTag => Terminal::CloseTag,
            TokenKind::OpenBrace => Terminal::OpenBrace,
            TokenKind::CloseBrace => Terminal::CloseBrace,
            TokenKind::OpenBracket => Terminal::OpenBracket,
            TokenKind::CloseBracket => Terminal::CloseBracket,
            TokenKind::AtSign => Terminal::AtSign,
            TokenKind::Dots => Terminal::Dots,
            TokenKind::Semicolon => Terminal::Semicolon,
            TokenKind::Namespace => {
                Terminal::Namespace(shexml_actions::namespace(context, token))
            }
            TokenKind::Identifier => {
                Terminal::Identifier(shexml_actions::identifier(context, token))
            }
            TokenKind::PathLiteral => {
                Terminal::PathLiteral(shexml_actions::path_literal(context, token))
            }
            TokenKind::Path => Terminal::Path(shexml_actions::path(context, token)),
            TokenKind::ShapePath => {
                Terminal::ShapePath(shexml_actions::shape_path(context, token))
            }
            TokenKind::Uri => Terminal::Uri(shexml_actions::uri(context, token)),
        };
        self.res_stack.push(Symbol::Terminal(val));
    }
    fn reduce_action(
        &mut self,
        context: &Context<'i, Input>,
        prod: ProdKind,
        prod_len: usize,
    ) {
        let prod = match prod {
            ProdKind::ShexmlP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::Declaration0(p0)),
                        Symbol::NonTerminal(NonTerminal::Shape0(p1)),
                    ) => NonTerminal::Shexml(shexml_actions::shexml_c1(context, p0, p1)),
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Declaration1P1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::Declaration1(p0)),
                        Symbol::NonTerminal(NonTerminal::Declaration(p1)),
                    ) => {
                        NonTerminal::Declaration1(
                            shexml_actions::declaration1_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Declaration1P2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::Declaration(p0)) => {
                        NonTerminal::Declaration1(
                            shexml_actions::declaration1_declaration(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Declaration0P1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::Declaration1(p0)) => {
                        NonTerminal::Declaration0(
                            shexml_actions::declaration0_declaration1(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Declaration0P2 => {
                NonTerminal::Declaration0(shexml_actions::declaration0_empty(context))
            }
            ProdKind::Shape1P1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::Shape1(p0)),
                        Symbol::NonTerminal(NonTerminal::Shape(p1)),
                    ) => NonTerminal::Shape1(shexml_actions::shape1_c1(context, p0, p1)),
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Shape1P2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::Shape(p0)) => {
                        NonTerminal::Shape1(shexml_actions::shape1_shape(context, p0))
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Shape0P1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::Shape1(p0)) => {
                        NonTerminal::Shape0(shexml_actions::shape0_shape1(context, p0))
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Shape0P2 => {
                NonTerminal::Shape0(shexml_actions::shape0_empty(context))
            }
            ProdKind::DeclarationP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::Prefix(p0)) => {
                        NonTerminal::Declaration(
                            shexml_actions::declaration_prefix(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::DeclarationP2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::Source(p0)) => {
                        NonTerminal::Declaration(
                            shexml_actions::declaration_source(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::DeclarationP3 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::Expression(p0)) => {
                        NonTerminal::Declaration(
                            shexml_actions::declaration_expression(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::DeclarationP4 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::Iterator(p0)) => {
                        NonTerminal::Declaration(
                            shexml_actions::declaration_iterator(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::PrefixP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 5usize)
                    .into_iter();
                match (
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                ) {
                    (
                        _,
                        Symbol::Terminal(Terminal::Namespace(p0)),
                        _,
                        Symbol::Terminal(Terminal::Uri(p1)),
                        _,
                    ) => NonTerminal::Prefix(shexml_actions::prefix_c1(context, p0, p1)),
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::SourceP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 5usize)
                    .into_iter();
                match (
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                ) {
                    (
                        _,
                        Symbol::Terminal(Terminal::Identifier(p0)),
                        _,
                        Symbol::Terminal(Terminal::Uri(p1)),
                        _,
                    ) => NonTerminal::Source(shexml_actions::source_c1(context, p0, p1)),
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ExpressionP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 5usize)
                    .into_iter();
                match (
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                ) {
                    (
                        _,
                        Symbol::Terminal(Terminal::Identifier(p0)),
                        _,
                        Symbol::NonTerminal(NonTerminal::Path1(p1)),
                        _,
                    ) => {
                        NonTerminal::Expression(
                            shexml_actions::expression_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Path1P1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 3usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::Path1(p0)),
                        _,
                        Symbol::Terminal(Terminal::Path(p1)),
                    ) => NonTerminal::Path1(shexml_actions::path1_c1(context, p0, p1)),
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Path1P2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::Terminal(Terminal::Path(p0)) => {
                        NonTerminal::Path1(shexml_actions::path1_path(context, p0))
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::IteratorP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 10usize)
                    .into_iter();
                match (
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                ) {
                    (
                        _,
                        Symbol::Terminal(Terminal::Identifier(p0)),
                        _,
                        Symbol::Terminal(Terminal::PathLiteral(p1)),
                        Symbol::Terminal(Terminal::Path(p2)),
                        _,
                        _,
                        Symbol::NonTerminal(NonTerminal::Attribute1(p3)),
                        Symbol::NonTerminal(NonTerminal::Nestedterator0(p4)),
                        _,
                    ) => {
                        NonTerminal::Iterator(
                            shexml_actions::iterator_c1(context, p0, p1, p2, p3, p4),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Attribute1P1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::Attribute1(p0)),
                        Symbol::NonTerminal(NonTerminal::Attribute(p1)),
                    ) => {
                        NonTerminal::Attribute1(
                            shexml_actions::attribute1_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Attribute1P2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::Attribute(p0)) => {
                        NonTerminal::Attribute1(
                            shexml_actions::attribute1_attribute(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Nestedterator1P1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::Nestedterator1(p0)),
                        Symbol::NonTerminal(NonTerminal::Nestedterator(p1)),
                    ) => {
                        NonTerminal::Nestedterator1(
                            shexml_actions::nestedterator1_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Nestedterator1P2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::Nestedterator(p0)) => {
                        NonTerminal::Nestedterator1(
                            shexml_actions::nestedterator1_nestedterator(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Nestedterator0P1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::Nestedterator1(p0)) => {
                        NonTerminal::Nestedterator0(
                            shexml_actions::nestedterator0_nestedterator1(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Nestedterator0P2 => {
                NonTerminal::Nestedterator0(
                    shexml_actions::nestedterator0_empty(context),
                )
            }
            ProdKind::NestedteratorP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 9usize)
                    .into_iter();
                match (
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                ) {
                    (
                        _,
                        Symbol::Terminal(Terminal::Identifier(p0)),
                        _,
                        Symbol::Terminal(Terminal::Path(p1)),
                        _,
                        _,
                        Symbol::NonTerminal(NonTerminal::Attribute1(p2)),
                        Symbol::NonTerminal(NonTerminal::Iterator0(p3)),
                        _,
                    ) => {
                        NonTerminal::Nestedterator(
                            shexml_actions::nestedterator_c1(context, p0, p1, p2, p3),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Iterator1P1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::Iterator1(p0)),
                        Symbol::NonTerminal(NonTerminal::Iterator(p1)),
                    ) => {
                        NonTerminal::Iterator1(
                            shexml_actions::iterator1_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Iterator1P2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::Iterator(p0)) => {
                        NonTerminal::Iterator1(
                            shexml_actions::iterator1_iterator(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Iterator0P1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::Iterator1(p0)) => {
                        NonTerminal::Iterator0(
                            shexml_actions::iterator0_iterator1(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Iterator0P2 => {
                NonTerminal::Iterator0(shexml_actions::iterator0_empty(context))
            }
            ProdKind::AttributeP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 5usize)
                    .into_iter();
                match (
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                ) {
                    (
                        _,
                        Symbol::Terminal(Terminal::Identifier(p0)),
                        _,
                        Symbol::Terminal(Terminal::Path(p1)),
                        _,
                    ) => {
                        NonTerminal::Attribute(
                            shexml_actions::attribute_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ShapeP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 4usize)
                    .into_iter();
                match (
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                ) {
                    (
                        Symbol::NonTerminal(NonTerminal::Subject(p0)),
                        _,
                        Symbol::NonTerminal(NonTerminal::PredicateObject0(p1)),
                        _,
                    ) => NonTerminal::Shape(shexml_actions::shape_c1(context, p0, p1)),
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::PredicateObject1P1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::PredicateObject1(p0)),
                        Symbol::NonTerminal(NonTerminal::PredicateObject(p1)),
                    ) => {
                        NonTerminal::PredicateObject1(
                            shexml_actions::predicate_object1_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::PredicateObject1P2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::PredicateObject(p0)) => {
                        NonTerminal::PredicateObject1(
                            shexml_actions::predicate_object1_predicate_object(
                                context,
                                p0,
                            ),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::PredicateObject0P1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::PredicateObject1(p0)) => {
                        NonTerminal::PredicateObject0(
                            shexml_actions::predicate_object0_predicate_object1(
                                context,
                                p0,
                            ),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::PredicateObject0P2 => {
                NonTerminal::PredicateObject0(
                    shexml_actions::predicate_object0_empty(context),
                )
            }
            ProdKind::SubjectP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::Class(p0)),
                        Symbol::NonTerminal(NonTerminal::SubjectIdentifier(p1)),
                    ) => {
                        NonTerminal::Subject(shexml_actions::subject_c1(context, p0, p1))
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ClassP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::Terminal(Terminal::Namespace(p0)),
                        Symbol::Terminal(Terminal::Identifier(p1)),
                    ) => NonTerminal::Class(shexml_actions::class_c1(context, p0, p1)),
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::SubjectIdentifierP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 4usize)
                    .into_iter();
                match (
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                ) {
                    (
                        Symbol::NonTerminal(NonTerminal::NamespaceOpt(p0)),
                        _,
                        Symbol::Terminal(Terminal::ShapePath(p1)),
                        _,
                    ) => {
                        NonTerminal::SubjectIdentifier(
                            shexml_actions::subject_identifier_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::NamespaceOptP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::Terminal(Terminal::Namespace(p0)) => {
                        NonTerminal::NamespaceOpt(
                            shexml_actions::namespace_opt_namespace(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::NamespaceOptP2 => {
                NonTerminal::NamespaceOpt(shexml_actions::namespace_opt_empty(context))
            }
            ProdKind::PredicateObjectP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 3usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::Predicate(p0)),
                        Symbol::NonTerminal(NonTerminal::Object(p1)),
                        _,
                    ) => {
                        NonTerminal::PredicateObject(
                            shexml_actions::predicate_object_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::PredicateP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::Terminal(Terminal::Namespace(p0)),
                        Symbol::Terminal(Terminal::Identifier(p1)),
                    ) => {
                        NonTerminal::Predicate(
                            shexml_actions::predicate_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ObjectP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::DataValue(p0)) => {
                        NonTerminal::Object(
                            shexml_actions::object_data_value(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ObjectP2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::Reference(p0)) => {
                        NonTerminal::Object(
                            shexml_actions::object_reference(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::DataValueP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 4usize)
                    .into_iter();
                match (
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                ) {
                    (
                        Symbol::NonTerminal(NonTerminal::NamespaceOpt(p0)),
                        _,
                        Symbol::Terminal(Terminal::ShapePath(p1)),
                        _,
                    ) => {
                        NonTerminal::DataValue(
                            shexml_actions::data_value_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ReferenceP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 3usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap(), i.next().unwrap()) {
                    (_, _, Symbol::Terminal(Terminal::Identifier(p0))) => {
                        NonTerminal::Reference(shexml_actions::reference_c1(context, p0))
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
        };
        self.res_stack.push(Symbol::NonTerminal(prod));
    }
}
