/// Generated by rustemo. Do not edit manually!
use std::fmt::Debug;
use std::hash::Hash;
use rustemo::{
    Result, Input as InputT, Lexer, Token, TokenRecognizer as TokenRecognizerT, Parser,
    ParserDefinition, State as StateT, Builder,
};
use rustemo::regex::Regex;
use rustemo::once_cell::sync::Lazy;
use rustemo::StringLexer;
use rustemo::LRBuilder;
use super::shexml_actions;
use rustemo::{LRParser, LRContext};
use rustemo::Action::{self, Shift, Reduce, Accept};
#[allow(unused_imports)]
use rustemo::debug::{log, logn};
#[allow(unused_imports)]
#[cfg(debug_assertions)]
use rustemo::colored::*;
pub type Input = str;
const STATE_COUNT: usize = 91usize;
const MAX_RECOGNIZERS: usize = 6usize;
#[allow(dead_code)]
const TERMINAL_COUNT: usize = 23usize;
#[allow(clippy::upper_case_acronyms)]
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum TokenKind {
    #[default]
    STOP,
    PrefixLiteral,
    SourceLiteral,
    IteratorLiteral,
    FieldLiteral,
    ExpressionLiteral,
    UnionLiteral,
    OpenTag,
    CloseTag,
    OpenBrace,
    CloseBrace,
    OpenBracket,
    CloseBracket,
    AtSign,
    Dots,
    Semicolon,
    Namespace,
    Identifier,
    PathLiteral,
    Path,
    ShapePath,
    Uri,
    Dot,
}
use TokenKind as TK;
impl From<TokenKind> for usize {
    fn from(t: TokenKind) -> Self {
        t as usize
    }
}
#[allow(clippy::enum_variant_names)]
#[derive(Clone, Copy, PartialEq)]
pub enum ProdKind {
    ShexmlP1,
    Prefix1P1,
    Prefix1P2,
    Prefix0P1,
    Prefix0P2,
    Source1P1,
    Source1P2,
    Source0P1,
    Source0P2,
    Iterator1P1,
    Iterator1P2,
    Iterator0P1,
    Iterator0P2,
    Expression1P1,
    Expression1P2,
    Expression0P1,
    Expression0P2,
    Shape1P1,
    Shape1P2,
    Shape0P1,
    Shape0P2,
    PrefixP1,
    SourceP1,
    ExpressionP1,
    IteratorFileRelation1P1,
    IteratorFileRelation1P2,
    IteratorFileRelationP1,
    IteratorP1,
    PathLiteralOptP1,
    PathLiteralOptP2,
    Attribute1P1,
    Attribute1P2,
    AttributeP1,
    ShapeP1,
    PredicateObject1P1,
    PredicateObject1P2,
    PredicateObject0P1,
    PredicateObject0P2,
    SubjectP1,
    ClassP1,
    SubjectIdentifierP1,
    NamespaceOptP1,
    NamespaceOptP2,
    PredicateObjectP1,
    PredicateP1,
    ObjectP1,
    ObjectP2,
    DataValueP1,
    ReferenceP1,
}
use ProdKind as PK;
impl std::fmt::Debug for ProdKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let name = match self {
            ProdKind::ShexmlP1 => "Shexml: Prefix0 Source0 Iterator0 Expression0 Shape0",
            ProdKind::Prefix1P1 => "Prefix1: Prefix1 Prefix",
            ProdKind::Prefix1P2 => "Prefix1: Prefix",
            ProdKind::Prefix0P1 => "Prefix0: Prefix1",
            ProdKind::Prefix0P2 => "Prefix0: ",
            ProdKind::Source1P1 => "Source1: Source1 Source",
            ProdKind::Source1P2 => "Source1: Source",
            ProdKind::Source0P1 => "Source0: Source1",
            ProdKind::Source0P2 => "Source0: ",
            ProdKind::Iterator1P1 => "Iterator1: Iterator1 Iterator",
            ProdKind::Iterator1P2 => "Iterator1: Iterator",
            ProdKind::Iterator0P1 => "Iterator0: Iterator1",
            ProdKind::Iterator0P2 => "Iterator0: ",
            ProdKind::Expression1P1 => "Expression1: Expression1 Expression",
            ProdKind::Expression1P2 => "Expression1: Expression",
            ProdKind::Expression0P1 => "Expression0: Expression1",
            ProdKind::Expression0P2 => "Expression0: ",
            ProdKind::Shape1P1 => "Shape1: Shape1 Shape",
            ProdKind::Shape1P2 => "Shape1: Shape",
            ProdKind::Shape0P1 => "Shape0: Shape1",
            ProdKind::Shape0P2 => "Shape0: ",
            ProdKind::PrefixP1 => "Prefix: PrefixLiteral Namespace OpenTag Uri CloseTag",
            ProdKind::SourceP1 => "Source: SourceLiteral Identifier OpenTag Uri CloseTag",
            ProdKind::ExpressionP1 => {
                "Expression: ExpressionLiteral Identifier OpenTag IteratorFileRelation1 CloseTag"
            }
            ProdKind::IteratorFileRelation1P1 => {
                "IteratorFileRelation1: IteratorFileRelation1 UnionLiteral IteratorFileRelation"
            }
            ProdKind::IteratorFileRelation1P2 => {
                "IteratorFileRelation1: IteratorFileRelation"
            }
            ProdKind::IteratorFileRelationP1 => {
                "IteratorFileRelation: Identifier Dot Identifier"
            }
            ProdKind::IteratorP1 => {
                "Iterator: IteratorLiteral Identifier OpenTag PathLiteralOpt Path CloseTag OpenBrace Attribute1 Iterator0 CloseBrace"
            }
            ProdKind::PathLiteralOptP1 => "PathLiteralOpt: PathLiteral",
            ProdKind::PathLiteralOptP2 => "PathLiteralOpt: ",
            ProdKind::Attribute1P1 => "Attribute1: Attribute1 Attribute",
            ProdKind::Attribute1P2 => "Attribute1: Attribute",
            ProdKind::AttributeP1 => {
                "Attribute: FieldLiteral Identifier OpenTag Path CloseTag"
            }
            ProdKind::ShapeP1 => "Shape: Subject OpenBrace PredicateObject0 CloseBrace",
            ProdKind::PredicateObject1P1 => {
                "PredicateObject1: PredicateObject1 PredicateObject"
            }
            ProdKind::PredicateObject1P2 => "PredicateObject1: PredicateObject",
            ProdKind::PredicateObject0P1 => "PredicateObject0: PredicateObject1",
            ProdKind::PredicateObject0P2 => "PredicateObject0: ",
            ProdKind::SubjectP1 => "Subject: Class SubjectIdentifier",
            ProdKind::ClassP1 => "Class: Namespace Identifier",
            ProdKind::SubjectIdentifierP1 => {
                "SubjectIdentifier: NamespaceOpt OpenBracket ShapePath CloseBracket"
            }
            ProdKind::NamespaceOptP1 => "NamespaceOpt: Namespace",
            ProdKind::NamespaceOptP2 => "NamespaceOpt: ",
            ProdKind::PredicateObjectP1 => "PredicateObject: Predicate Object Semicolon",
            ProdKind::PredicateP1 => "Predicate: Namespace Identifier",
            ProdKind::ObjectP1 => "Object: DataValue",
            ProdKind::ObjectP2 => "Object: Reference",
            ProdKind::DataValueP1 => {
                "DataValue: NamespaceOpt OpenBracket ShapePath CloseBracket"
            }
            ProdKind::ReferenceP1 => "Reference: AtSign Namespace Identifier",
        };
        write!(f, "{}", name)
    }
}
#[allow(clippy::upper_case_acronyms)]
#[allow(dead_code)]
#[derive(Clone, Copy, Debug)]
pub enum NonTermKind {
    EMPTY,
    AUG,
    Shexml,
    Prefix1,
    Prefix0,
    Source1,
    Source0,
    Iterator1,
    Iterator0,
    Expression1,
    Expression0,
    Shape1,
    Shape0,
    Prefix,
    Source,
    Expression,
    IteratorFileRelation1,
    IteratorFileRelation,
    Iterator,
    PathLiteralOpt,
    Attribute1,
    Attribute,
    Shape,
    PredicateObject1,
    PredicateObject0,
    Subject,
    Class,
    SubjectIdentifier,
    NamespaceOpt,
    PredicateObject,
    Predicate,
    Object,
    DataValue,
    Reference,
}
impl From<ProdKind> for NonTermKind {
    fn from(prod: ProdKind) -> Self {
        match prod {
            ProdKind::ShexmlP1 => NonTermKind::Shexml,
            ProdKind::Prefix1P1 => NonTermKind::Prefix1,
            ProdKind::Prefix1P2 => NonTermKind::Prefix1,
            ProdKind::Prefix0P1 => NonTermKind::Prefix0,
            ProdKind::Prefix0P2 => NonTermKind::Prefix0,
            ProdKind::Source1P1 => NonTermKind::Source1,
            ProdKind::Source1P2 => NonTermKind::Source1,
            ProdKind::Source0P1 => NonTermKind::Source0,
            ProdKind::Source0P2 => NonTermKind::Source0,
            ProdKind::Iterator1P1 => NonTermKind::Iterator1,
            ProdKind::Iterator1P2 => NonTermKind::Iterator1,
            ProdKind::Iterator0P1 => NonTermKind::Iterator0,
            ProdKind::Iterator0P2 => NonTermKind::Iterator0,
            ProdKind::Expression1P1 => NonTermKind::Expression1,
            ProdKind::Expression1P2 => NonTermKind::Expression1,
            ProdKind::Expression0P1 => NonTermKind::Expression0,
            ProdKind::Expression0P2 => NonTermKind::Expression0,
            ProdKind::Shape1P1 => NonTermKind::Shape1,
            ProdKind::Shape1P2 => NonTermKind::Shape1,
            ProdKind::Shape0P1 => NonTermKind::Shape0,
            ProdKind::Shape0P2 => NonTermKind::Shape0,
            ProdKind::PrefixP1 => NonTermKind::Prefix,
            ProdKind::SourceP1 => NonTermKind::Source,
            ProdKind::ExpressionP1 => NonTermKind::Expression,
            ProdKind::IteratorFileRelation1P1 => NonTermKind::IteratorFileRelation1,
            ProdKind::IteratorFileRelation1P2 => NonTermKind::IteratorFileRelation1,
            ProdKind::IteratorFileRelationP1 => NonTermKind::IteratorFileRelation,
            ProdKind::IteratorP1 => NonTermKind::Iterator,
            ProdKind::PathLiteralOptP1 => NonTermKind::PathLiteralOpt,
            ProdKind::PathLiteralOptP2 => NonTermKind::PathLiteralOpt,
            ProdKind::Attribute1P1 => NonTermKind::Attribute1,
            ProdKind::Attribute1P2 => NonTermKind::Attribute1,
            ProdKind::AttributeP1 => NonTermKind::Attribute,
            ProdKind::ShapeP1 => NonTermKind::Shape,
            ProdKind::PredicateObject1P1 => NonTermKind::PredicateObject1,
            ProdKind::PredicateObject1P2 => NonTermKind::PredicateObject1,
            ProdKind::PredicateObject0P1 => NonTermKind::PredicateObject0,
            ProdKind::PredicateObject0P2 => NonTermKind::PredicateObject0,
            ProdKind::SubjectP1 => NonTermKind::Subject,
            ProdKind::ClassP1 => NonTermKind::Class,
            ProdKind::SubjectIdentifierP1 => NonTermKind::SubjectIdentifier,
            ProdKind::NamespaceOptP1 => NonTermKind::NamespaceOpt,
            ProdKind::NamespaceOptP2 => NonTermKind::NamespaceOpt,
            ProdKind::PredicateObjectP1 => NonTermKind::PredicateObject,
            ProdKind::PredicateP1 => NonTermKind::Predicate,
            ProdKind::ObjectP1 => NonTermKind::Object,
            ProdKind::ObjectP2 => NonTermKind::Object,
            ProdKind::DataValueP1 => NonTermKind::DataValue,
            ProdKind::ReferenceP1 => NonTermKind::Reference,
        }
    }
}
#[allow(clippy::enum_variant_names)]
#[derive(Default, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum State {
    #[default]
    AUGS0,
    PrefixLiteralS1,
    ShexmlS2,
    Prefix1S3,
    Prefix0S4,
    PrefixS5,
    NamespaceS6,
    PrefixS7,
    SourceLiteralS8,
    Source1S9,
    Source0S10,
    SourceS11,
    OpenTagS12,
    IdentifierS13,
    SourceS14,
    IteratorLiteralS15,
    Iterator1S16,
    Iterator0S17,
    IteratorS18,
    UriS19,
    OpenTagS20,
    IdentifierS21,
    IteratorS22,
    ExpressionLiteralS23,
    Expression1S24,
    Expression0S25,
    ExpressionS26,
    CloseTagS27,
    UriS28,
    OpenTagS29,
    IdentifierS30,
    ExpressionS31,
    NamespaceS32,
    Shape1S33,
    Shape0S34,
    ShapeS35,
    SubjectS36,
    ClassS37,
    CloseTagS38,
    PathLiteralS39,
    PathLiteralOptS40,
    OpenTagS41,
    IdentifierS42,
    ShapeS43,
    OpenBraceS44,
    NamespaceS45,
    SubjectIdentifierS46,
    NamespaceOptS47,
    PathS48,
    IdentifierS49,
    IteratorFileRelation1S50,
    IteratorFileRelationS51,
    NamespaceS52,
    PredicateObject1S53,
    PredicateObject0S54,
    PredicateObjectS55,
    PredicateS56,
    OpenBracketS57,
    CloseTagS58,
    DotS59,
    UnionLiteralS60,
    CloseTagS61,
    IdentifierS62,
    PredicateObjectS63,
    CloseBraceS64,
    AtSignS65,
    NamespaceOptS66,
    ObjectS67,
    DataValueS68,
    ReferenceS69,
    ShapePathS70,
    OpenBraceS71,
    IdentifierS72,
    IteratorFileRelationS73,
    NamespaceS74,
    OpenBracketS75,
    SemicolonS76,
    CloseBracketS77,
    FieldLiteralS78,
    Attribute1S79,
    AttributeS80,
    IdentifierS81,
    ShapePathS82,
    IdentifierS83,
    Iterator0S84,
    AttributeS85,
    CloseBracketS86,
    OpenTagS87,
    CloseBraceS88,
    PathS89,
    CloseTagS90,
}
impl StateT for State {
    fn default_layout() -> Option<Self> {
        None
    }
}
impl From<State> for usize {
    fn from(s: State) -> Self {
        s as usize
    }
}
impl std::fmt::Debug for State {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let name = match self {
            State::AUGS0 => "0:AUG",
            State::PrefixLiteralS1 => "1:PrefixLiteral",
            State::ShexmlS2 => "2:Shexml",
            State::Prefix1S3 => "3:Prefix1",
            State::Prefix0S4 => "4:Prefix0",
            State::PrefixS5 => "5:Prefix",
            State::NamespaceS6 => "6:Namespace",
            State::PrefixS7 => "7:Prefix",
            State::SourceLiteralS8 => "8:SourceLiteral",
            State::Source1S9 => "9:Source1",
            State::Source0S10 => "10:Source0",
            State::SourceS11 => "11:Source",
            State::OpenTagS12 => "12:OpenTag",
            State::IdentifierS13 => "13:Identifier",
            State::SourceS14 => "14:Source",
            State::IteratorLiteralS15 => "15:IteratorLiteral",
            State::Iterator1S16 => "16:Iterator1",
            State::Iterator0S17 => "17:Iterator0",
            State::IteratorS18 => "18:Iterator",
            State::UriS19 => "19:Uri",
            State::OpenTagS20 => "20:OpenTag",
            State::IdentifierS21 => "21:Identifier",
            State::IteratorS22 => "22:Iterator",
            State::ExpressionLiteralS23 => "23:ExpressionLiteral",
            State::Expression1S24 => "24:Expression1",
            State::Expression0S25 => "25:Expression0",
            State::ExpressionS26 => "26:Expression",
            State::CloseTagS27 => "27:CloseTag",
            State::UriS28 => "28:Uri",
            State::OpenTagS29 => "29:OpenTag",
            State::IdentifierS30 => "30:Identifier",
            State::ExpressionS31 => "31:Expression",
            State::NamespaceS32 => "32:Namespace",
            State::Shape1S33 => "33:Shape1",
            State::Shape0S34 => "34:Shape0",
            State::ShapeS35 => "35:Shape",
            State::SubjectS36 => "36:Subject",
            State::ClassS37 => "37:Class",
            State::CloseTagS38 => "38:CloseTag",
            State::PathLiteralS39 => "39:PathLiteral",
            State::PathLiteralOptS40 => "40:PathLiteralOpt",
            State::OpenTagS41 => "41:OpenTag",
            State::IdentifierS42 => "42:Identifier",
            State::ShapeS43 => "43:Shape",
            State::OpenBraceS44 => "44:OpenBrace",
            State::NamespaceS45 => "45:Namespace",
            State::SubjectIdentifierS46 => "46:SubjectIdentifier",
            State::NamespaceOptS47 => "47:NamespaceOpt",
            State::PathS48 => "48:Path",
            State::IdentifierS49 => "49:Identifier",
            State::IteratorFileRelation1S50 => "50:IteratorFileRelation1",
            State::IteratorFileRelationS51 => "51:IteratorFileRelation",
            State::NamespaceS52 => "52:Namespace",
            State::PredicateObject1S53 => "53:PredicateObject1",
            State::PredicateObject0S54 => "54:PredicateObject0",
            State::PredicateObjectS55 => "55:PredicateObject",
            State::PredicateS56 => "56:Predicate",
            State::OpenBracketS57 => "57:OpenBracket",
            State::CloseTagS58 => "58:CloseTag",
            State::DotS59 => "59:Dot",
            State::UnionLiteralS60 => "60:UnionLiteral",
            State::CloseTagS61 => "61:CloseTag",
            State::IdentifierS62 => "62:Identifier",
            State::PredicateObjectS63 => "63:PredicateObject",
            State::CloseBraceS64 => "64:CloseBrace",
            State::AtSignS65 => "65:AtSign",
            State::NamespaceOptS66 => "66:NamespaceOpt",
            State::ObjectS67 => "67:Object",
            State::DataValueS68 => "68:DataValue",
            State::ReferenceS69 => "69:Reference",
            State::ShapePathS70 => "70:ShapePath",
            State::OpenBraceS71 => "71:OpenBrace",
            State::IdentifierS72 => "72:Identifier",
            State::IteratorFileRelationS73 => "73:IteratorFileRelation",
            State::NamespaceS74 => "74:Namespace",
            State::OpenBracketS75 => "75:OpenBracket",
            State::SemicolonS76 => "76:Semicolon",
            State::CloseBracketS77 => "77:CloseBracket",
            State::FieldLiteralS78 => "78:FieldLiteral",
            State::Attribute1S79 => "79:Attribute1",
            State::AttributeS80 => "80:Attribute",
            State::IdentifierS81 => "81:Identifier",
            State::ShapePathS82 => "82:ShapePath",
            State::IdentifierS83 => "83:Identifier",
            State::Iterator0S84 => "84:Iterator0",
            State::AttributeS85 => "85:Attribute",
            State::CloseBracketS86 => "86:CloseBracket",
            State::OpenTagS87 => "87:OpenTag",
            State::CloseBraceS88 => "88:CloseBrace",
            State::PathS89 => "89:Path",
            State::CloseTagS90 => "90:CloseTag",
        };
        write!(f, "{name}")
    }
}
#[derive(Debug)]
pub enum Symbol {
    Terminal(Terminal),
    NonTerminal(NonTerminal),
}
#[allow(clippy::upper_case_acronyms)]
#[derive(Debug)]
pub enum Terminal {
    PrefixLiteral,
    SourceLiteral,
    IteratorLiteral,
    FieldLiteral,
    ExpressionLiteral,
    UnionLiteral,
    OpenTag,
    CloseTag,
    OpenBrace,
    CloseBrace,
    OpenBracket,
    CloseBracket,
    AtSign,
    Semicolon,
    Namespace(shexml_actions::Namespace),
    Identifier(shexml_actions::Identifier),
    PathLiteral(shexml_actions::PathLiteral),
    Path(shexml_actions::Path),
    ShapePath(shexml_actions::ShapePath),
    Uri(shexml_actions::Uri),
    Dot,
}
#[derive(Debug)]
pub enum NonTerminal {
    Shexml(shexml_actions::Shexml),
    Prefix1(shexml_actions::Prefix1),
    Prefix0(shexml_actions::Prefix0),
    Source1(shexml_actions::Source1),
    Source0(shexml_actions::Source0),
    Iterator1(shexml_actions::Iterator1),
    Iterator0(shexml_actions::Iterator0),
    Expression1(shexml_actions::Expression1),
    Expression0(shexml_actions::Expression0),
    Shape1(shexml_actions::Shape1),
    Shape0(shexml_actions::Shape0),
    Prefix(shexml_actions::Prefix),
    Source(shexml_actions::Source),
    Expression(shexml_actions::Expression),
    IteratorFileRelation1(shexml_actions::IteratorFileRelation1),
    IteratorFileRelation(shexml_actions::IteratorFileRelation),
    Iterator(shexml_actions::Iterator),
    PathLiteralOpt(shexml_actions::PathLiteralOpt),
    Attribute1(shexml_actions::Attribute1),
    Attribute(shexml_actions::Attribute),
    Shape(shexml_actions::Shape),
    PredicateObject1(shexml_actions::PredicateObject1),
    PredicateObject0(shexml_actions::PredicateObject0),
    Subject(shexml_actions::Subject),
    Class(shexml_actions::Class),
    SubjectIdentifier(shexml_actions::SubjectIdentifier),
    NamespaceOpt(shexml_actions::NamespaceOpt),
    PredicateObject(shexml_actions::PredicateObject),
    Predicate(shexml_actions::Predicate),
    Object(shexml_actions::Object),
    DataValue(shexml_actions::DataValue),
    Reference(shexml_actions::Reference),
}
type ActionFn = fn(token: TokenKind) -> Vec<Action<State, ProdKind>>;
pub struct ShexmlParserDefinition {
    actions: [ActionFn; STATE_COUNT],
    gotos: [fn(nonterm: NonTermKind) -> State; STATE_COUNT],
    token_kinds: [[Option<(TokenKind, bool)>; MAX_RECOGNIZERS]; STATE_COUNT],
}
fn action_aug_s0(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::Prefix0P2, 0usize)]),
        TK::PrefixLiteral => Vec::from(&[Shift(State::PrefixLiteralS1)]),
        TK::SourceLiteral => Vec::from(&[Reduce(PK::Prefix0P2, 0usize)]),
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::Prefix0P2, 0usize)]),
        TK::ExpressionLiteral => Vec::from(&[Reduce(PK::Prefix0P2, 0usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::Prefix0P2, 0usize)]),
        _ => vec![],
    }
}
fn action_prefixliteral_s1(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Namespace => Vec::from(&[Shift(State::NamespaceS6)]),
        _ => vec![],
    }
}
fn action_shexml_s2(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Accept]),
        _ => vec![],
    }
}
fn action_prefix1_s3(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::Prefix0P1, 1usize)]),
        TK::PrefixLiteral => Vec::from(&[Shift(State::PrefixLiteralS1)]),
        TK::SourceLiteral => Vec::from(&[Reduce(PK::Prefix0P1, 1usize)]),
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::Prefix0P1, 1usize)]),
        TK::ExpressionLiteral => Vec::from(&[Reduce(PK::Prefix0P1, 1usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::Prefix0P1, 1usize)]),
        _ => vec![],
    }
}
fn action_prefix0_s4(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::Source0P2, 0usize)]),
        TK::SourceLiteral => Vec::from(&[Shift(State::SourceLiteralS8)]),
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::Source0P2, 0usize)]),
        TK::ExpressionLiteral => Vec::from(&[Reduce(PK::Source0P2, 0usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::Source0P2, 0usize)]),
        _ => vec![],
    }
}
fn action_prefix_s5(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::Prefix1P2, 1usize)]),
        TK::PrefixLiteral => Vec::from(&[Reduce(PK::Prefix1P2, 1usize)]),
        TK::SourceLiteral => Vec::from(&[Reduce(PK::Prefix1P2, 1usize)]),
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::Prefix1P2, 1usize)]),
        TK::ExpressionLiteral => Vec::from(&[Reduce(PK::Prefix1P2, 1usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::Prefix1P2, 1usize)]),
        _ => vec![],
    }
}
fn action_namespace_s6(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenTag => Vec::from(&[Shift(State::OpenTagS12)]),
        _ => vec![],
    }
}
fn action_prefix_s7(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::Prefix1P1, 2usize)]),
        TK::PrefixLiteral => Vec::from(&[Reduce(PK::Prefix1P1, 2usize)]),
        TK::SourceLiteral => Vec::from(&[Reduce(PK::Prefix1P1, 2usize)]),
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::Prefix1P1, 2usize)]),
        TK::ExpressionLiteral => Vec::from(&[Reduce(PK::Prefix1P1, 2usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::Prefix1P1, 2usize)]),
        _ => vec![],
    }
}
fn action_sourceliteral_s8(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS13)]),
        _ => vec![],
    }
}
fn action_source1_s9(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::Source0P1, 1usize)]),
        TK::SourceLiteral => Vec::from(&[Shift(State::SourceLiteralS8)]),
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::Source0P1, 1usize)]),
        TK::ExpressionLiteral => Vec::from(&[Reduce(PK::Source0P1, 1usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::Source0P1, 1usize)]),
        _ => vec![],
    }
}
fn action_source0_s10(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::Iterator0P2, 0usize)]),
        TK::IteratorLiteral => Vec::from(&[Shift(State::IteratorLiteralS15)]),
        TK::ExpressionLiteral => Vec::from(&[Reduce(PK::Iterator0P2, 0usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::Iterator0P2, 0usize)]),
        _ => vec![],
    }
}
fn action_source_s11(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::Source1P2, 1usize)]),
        TK::SourceLiteral => Vec::from(&[Reduce(PK::Source1P2, 1usize)]),
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::Source1P2, 1usize)]),
        TK::ExpressionLiteral => Vec::from(&[Reduce(PK::Source1P2, 1usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::Source1P2, 1usize)]),
        _ => vec![],
    }
}
fn action_opentag_s12(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Uri => Vec::from(&[Shift(State::UriS19)]),
        _ => vec![],
    }
}
fn action_identifier_s13(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenTag => Vec::from(&[Shift(State::OpenTagS20)]),
        _ => vec![],
    }
}
fn action_source_s14(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::Source1P1, 2usize)]),
        TK::SourceLiteral => Vec::from(&[Reduce(PK::Source1P1, 2usize)]),
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::Source1P1, 2usize)]),
        TK::ExpressionLiteral => Vec::from(&[Reduce(PK::Source1P1, 2usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::Source1P1, 2usize)]),
        _ => vec![],
    }
}
fn action_iteratorliteral_s15(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS21)]),
        _ => vec![],
    }
}
fn action_iterator1_s16(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::Iterator0P1, 1usize)]),
        TK::IteratorLiteral => Vec::from(&[Shift(State::IteratorLiteralS15)]),
        TK::ExpressionLiteral => Vec::from(&[Reduce(PK::Iterator0P1, 1usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::Iterator0P1, 1usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::Iterator0P1, 1usize)]),
        _ => vec![],
    }
}
fn action_iterator0_s17(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::Expression0P2, 0usize)]),
        TK::ExpressionLiteral => Vec::from(&[Shift(State::ExpressionLiteralS23)]),
        TK::Namespace => Vec::from(&[Reduce(PK::Expression0P2, 0usize)]),
        _ => vec![],
    }
}
fn action_iterator_s18(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::Iterator1P2, 1usize)]),
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::Iterator1P2, 1usize)]),
        TK::ExpressionLiteral => Vec::from(&[Reduce(PK::Iterator1P2, 1usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::Iterator1P2, 1usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::Iterator1P2, 1usize)]),
        _ => vec![],
    }
}
fn action_uri_s19(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::CloseTag => Vec::from(&[Shift(State::CloseTagS27)]),
        _ => vec![],
    }
}
fn action_opentag_s20(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Uri => Vec::from(&[Shift(State::UriS28)]),
        _ => vec![],
    }
}
fn action_identifier_s21(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenTag => Vec::from(&[Shift(State::OpenTagS29)]),
        _ => vec![],
    }
}
fn action_iterator_s22(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::Iterator1P1, 2usize)]),
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::Iterator1P1, 2usize)]),
        TK::ExpressionLiteral => Vec::from(&[Reduce(PK::Iterator1P1, 2usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::Iterator1P1, 2usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::Iterator1P1, 2usize)]),
        _ => vec![],
    }
}
fn action_expressionliteral_s23(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS30)]),
        _ => vec![],
    }
}
fn action_expression1_s24(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::Expression0P1, 1usize)]),
        TK::ExpressionLiteral => Vec::from(&[Shift(State::ExpressionLiteralS23)]),
        TK::Namespace => Vec::from(&[Reduce(PK::Expression0P1, 1usize)]),
        _ => vec![],
    }
}
fn action_expression0_s25(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::Shape0P2, 0usize)]),
        TK::Namespace => Vec::from(&[Shift(State::NamespaceS32)]),
        _ => vec![],
    }
}
fn action_expression_s26(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::Expression1P2, 1usize)]),
        TK::ExpressionLiteral => Vec::from(&[Reduce(PK::Expression1P2, 1usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::Expression1P2, 1usize)]),
        _ => vec![],
    }
}
fn action_closetag_s27(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::PrefixP1, 5usize)]),
        TK::PrefixLiteral => Vec::from(&[Reduce(PK::PrefixP1, 5usize)]),
        TK::SourceLiteral => Vec::from(&[Reduce(PK::PrefixP1, 5usize)]),
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::PrefixP1, 5usize)]),
        TK::ExpressionLiteral => Vec::from(&[Reduce(PK::PrefixP1, 5usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::PrefixP1, 5usize)]),
        _ => vec![],
    }
}
fn action_uri_s28(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::CloseTag => Vec::from(&[Shift(State::CloseTagS38)]),
        _ => vec![],
    }
}
fn action_opentag_s29(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::PathLiteral => Vec::from(&[Shift(State::PathLiteralS39)]),
        TK::Path => Vec::from(&[Reduce(PK::PathLiteralOptP2, 0usize)]),
        _ => vec![],
    }
}
fn action_identifier_s30(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenTag => Vec::from(&[Shift(State::OpenTagS41)]),
        _ => vec![],
    }
}
fn action_expression_s31(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::Expression1P1, 2usize)]),
        TK::ExpressionLiteral => Vec::from(&[Reduce(PK::Expression1P1, 2usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::Expression1P1, 2usize)]),
        _ => vec![],
    }
}
fn action_namespace_s32(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS42)]),
        _ => vec![],
    }
}
fn action_shape1_s33(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::Shape0P1, 1usize)]),
        TK::Namespace => Vec::from(&[Shift(State::NamespaceS32)]),
        _ => vec![],
    }
}
fn action_shape0_s34(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::ShexmlP1, 5usize)]),
        _ => vec![],
    }
}
fn action_shape_s35(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::Shape1P2, 1usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::Shape1P2, 1usize)]),
        _ => vec![],
    }
}
fn action_subject_s36(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenBrace => Vec::from(&[Shift(State::OpenBraceS44)]),
        _ => vec![],
    }
}
fn action_class_s37(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenBracket => Vec::from(&[Reduce(PK::NamespaceOptP2, 0usize)]),
        TK::Namespace => Vec::from(&[Shift(State::NamespaceS45)]),
        _ => vec![],
    }
}
fn action_closetag_s38(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::SourceP1, 5usize)]),
        TK::SourceLiteral => Vec::from(&[Reduce(PK::SourceP1, 5usize)]),
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::SourceP1, 5usize)]),
        TK::ExpressionLiteral => Vec::from(&[Reduce(PK::SourceP1, 5usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::SourceP1, 5usize)]),
        _ => vec![],
    }
}
fn action_pathliteral_s39(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Path => Vec::from(&[Reduce(PK::PathLiteralOptP1, 1usize)]),
        _ => vec![],
    }
}
fn action_pathliteralopt_s40(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Path => Vec::from(&[Shift(State::PathS48)]),
        _ => vec![],
    }
}
fn action_opentag_s41(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS49)]),
        _ => vec![],
    }
}
fn action_identifier_s42(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenBracket => Vec::from(&[Reduce(PK::ClassP1, 2usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::ClassP1, 2usize)]),
        _ => vec![],
    }
}
fn action_shape_s43(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::Shape1P1, 2usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::Shape1P1, 2usize)]),
        _ => vec![],
    }
}
fn action_openbrace_s44(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::CloseBrace => Vec::from(&[Reduce(PK::PredicateObject0P2, 0usize)]),
        TK::Namespace => Vec::from(&[Shift(State::NamespaceS52)]),
        _ => vec![],
    }
}
fn action_namespace_s45(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenBracket => Vec::from(&[Reduce(PK::NamespaceOptP1, 1usize)]),
        _ => vec![],
    }
}
fn action_subjectidentifier_s46(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenBrace => Vec::from(&[Reduce(PK::SubjectP1, 2usize)]),
        _ => vec![],
    }
}
fn action_namespaceopt_s47(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenBracket => Vec::from(&[Shift(State::OpenBracketS57)]),
        _ => vec![],
    }
}
fn action_path_s48(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::CloseTag => Vec::from(&[Shift(State::CloseTagS58)]),
        _ => vec![],
    }
}
fn action_identifier_s49(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Dot => Vec::from(&[Shift(State::DotS59)]),
        _ => vec![],
    }
}
fn action_iteratorfilerelation1_s50(
    token_kind: TokenKind,
) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::UnionLiteral => Vec::from(&[Shift(State::UnionLiteralS60)]),
        TK::CloseTag => Vec::from(&[Shift(State::CloseTagS61)]),
        _ => vec![],
    }
}
fn action_iteratorfilerelation_s51(
    token_kind: TokenKind,
) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::UnionLiteral => Vec::from(&[Reduce(PK::IteratorFileRelation1P2, 1usize)]),
        TK::CloseTag => Vec::from(&[Reduce(PK::IteratorFileRelation1P2, 1usize)]),
        _ => vec![],
    }
}
fn action_namespace_s52(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS62)]),
        _ => vec![],
    }
}
fn action_predicateobject1_s53(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::CloseBrace => Vec::from(&[Reduce(PK::PredicateObject0P1, 1usize)]),
        TK::Namespace => Vec::from(&[Shift(State::NamespaceS52)]),
        _ => vec![],
    }
}
fn action_predicateobject0_s54(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::CloseBrace => Vec::from(&[Shift(State::CloseBraceS64)]),
        _ => vec![],
    }
}
fn action_predicateobject_s55(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::CloseBrace => Vec::from(&[Reduce(PK::PredicateObject1P2, 1usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::PredicateObject1P2, 1usize)]),
        _ => vec![],
    }
}
fn action_predicate_s56(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenBracket => Vec::from(&[Reduce(PK::NamespaceOptP2, 0usize)]),
        TK::AtSign => Vec::from(&[Shift(State::AtSignS65)]),
        TK::Namespace => Vec::from(&[Shift(State::NamespaceS45)]),
        _ => vec![],
    }
}
fn action_openbracket_s57(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::ShapePath => Vec::from(&[Shift(State::ShapePathS70)]),
        _ => vec![],
    }
}
fn action_closetag_s58(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenBrace => Vec::from(&[Shift(State::OpenBraceS71)]),
        _ => vec![],
    }
}
fn action_dot_s59(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS72)]),
        _ => vec![],
    }
}
fn action_unionliteral_s60(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS49)]),
        _ => vec![],
    }
}
fn action_closetag_s61(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::ExpressionP1, 5usize)]),
        TK::ExpressionLiteral => Vec::from(&[Reduce(PK::ExpressionP1, 5usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::ExpressionP1, 5usize)]),
        _ => vec![],
    }
}
fn action_identifier_s62(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenBracket => Vec::from(&[Reduce(PK::PredicateP1, 2usize)]),
        TK::AtSign => Vec::from(&[Reduce(PK::PredicateP1, 2usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::PredicateP1, 2usize)]),
        _ => vec![],
    }
}
fn action_predicateobject_s63(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::CloseBrace => Vec::from(&[Reduce(PK::PredicateObject1P1, 2usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::PredicateObject1P1, 2usize)]),
        _ => vec![],
    }
}
fn action_closebrace_s64(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::ShapeP1, 4usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::ShapeP1, 4usize)]),
        _ => vec![],
    }
}
fn action_atsign_s65(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Namespace => Vec::from(&[Shift(State::NamespaceS74)]),
        _ => vec![],
    }
}
fn action_namespaceopt_s66(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenBracket => Vec::from(&[Shift(State::OpenBracketS75)]),
        _ => vec![],
    }
}
fn action_object_s67(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Semicolon => Vec::from(&[Shift(State::SemicolonS76)]),
        _ => vec![],
    }
}
fn action_datavalue_s68(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Semicolon => Vec::from(&[Reduce(PK::ObjectP1, 1usize)]),
        _ => vec![],
    }
}
fn action_reference_s69(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Semicolon => Vec::from(&[Reduce(PK::ObjectP2, 1usize)]),
        _ => vec![],
    }
}
fn action_shapepath_s70(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::CloseBracket => Vec::from(&[Shift(State::CloseBracketS77)]),
        _ => vec![],
    }
}
fn action_openbrace_s71(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::FieldLiteral => Vec::from(&[Shift(State::FieldLiteralS78)]),
        _ => vec![],
    }
}
fn action_identifier_s72(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::UnionLiteral => Vec::from(&[Reduce(PK::IteratorFileRelationP1, 3usize)]),
        TK::CloseTag => Vec::from(&[Reduce(PK::IteratorFileRelationP1, 3usize)]),
        _ => vec![],
    }
}
fn action_iteratorfilerelation_s73(
    token_kind: TokenKind,
) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::UnionLiteral => Vec::from(&[Reduce(PK::IteratorFileRelation1P1, 3usize)]),
        TK::CloseTag => Vec::from(&[Reduce(PK::IteratorFileRelation1P1, 3usize)]),
        _ => vec![],
    }
}
fn action_namespace_s74(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS81)]),
        _ => vec![],
    }
}
fn action_openbracket_s75(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::ShapePath => Vec::from(&[Shift(State::ShapePathS82)]),
        _ => vec![],
    }
}
fn action_semicolon_s76(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::CloseBrace => Vec::from(&[Reduce(PK::PredicateObjectP1, 3usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::PredicateObjectP1, 3usize)]),
        _ => vec![],
    }
}
fn action_closebracket_s77(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenBrace => Vec::from(&[Reduce(PK::SubjectIdentifierP1, 4usize)]),
        _ => vec![],
    }
}
fn action_fieldliteral_s78(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Identifier => Vec::from(&[Shift(State::IdentifierS83)]),
        _ => vec![],
    }
}
fn action_attribute1_s79(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::IteratorLiteral => Vec::from(&[Shift(State::IteratorLiteralS15)]),
        TK::FieldLiteral => Vec::from(&[Shift(State::FieldLiteralS78)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::Iterator0P2, 0usize)]),
        _ => vec![],
    }
}
fn action_attribute_s80(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::Attribute1P2, 1usize)]),
        TK::FieldLiteral => Vec::from(&[Reduce(PK::Attribute1P2, 1usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::Attribute1P2, 1usize)]),
        _ => vec![],
    }
}
fn action_identifier_s81(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Semicolon => Vec::from(&[Reduce(PK::ReferenceP1, 3usize)]),
        _ => vec![],
    }
}
fn action_shapepath_s82(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::CloseBracket => Vec::from(&[Shift(State::CloseBracketS86)]),
        _ => vec![],
    }
}
fn action_identifier_s83(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::OpenTag => Vec::from(&[Shift(State::OpenTagS87)]),
        _ => vec![],
    }
}
fn action_iterator0_s84(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::CloseBrace => Vec::from(&[Shift(State::CloseBraceS88)]),
        _ => vec![],
    }
}
fn action_attribute_s85(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::Attribute1P1, 2usize)]),
        TK::FieldLiteral => Vec::from(&[Reduce(PK::Attribute1P1, 2usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::Attribute1P1, 2usize)]),
        _ => vec![],
    }
}
fn action_closebracket_s86(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Semicolon => Vec::from(&[Reduce(PK::DataValueP1, 4usize)]),
        _ => vec![],
    }
}
fn action_opentag_s87(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::Path => Vec::from(&[Shift(State::PathS89)]),
        _ => vec![],
    }
}
fn action_closebrace_s88(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::STOP => Vec::from(&[Reduce(PK::IteratorP1, 10usize)]),
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::IteratorP1, 10usize)]),
        TK::ExpressionLiteral => Vec::from(&[Reduce(PK::IteratorP1, 10usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::IteratorP1, 10usize)]),
        TK::Namespace => Vec::from(&[Reduce(PK::IteratorP1, 10usize)]),
        _ => vec![],
    }
}
fn action_path_s89(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::CloseTag => Vec::from(&[Shift(State::CloseTagS90)]),
        _ => vec![],
    }
}
fn action_closetag_s90(token_kind: TokenKind) -> Vec<Action<State, ProdKind>> {
    match token_kind {
        TK::IteratorLiteral => Vec::from(&[Reduce(PK::AttributeP1, 5usize)]),
        TK::FieldLiteral => Vec::from(&[Reduce(PK::AttributeP1, 5usize)]),
        TK::CloseBrace => Vec::from(&[Reduce(PK::AttributeP1, 5usize)]),
        _ => vec![],
    }
}
fn goto_aug_s0(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Shexml => State::ShexmlS2,
        NonTermKind::Prefix1 => State::Prefix1S3,
        NonTermKind::Prefix0 => State::Prefix0S4,
        NonTermKind::Prefix => State::PrefixS5,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::AUGS0
            )
        }
    }
}
fn goto_prefix1_s3(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Prefix => State::PrefixS7,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::Prefix1S3
            )
        }
    }
}
fn goto_prefix0_s4(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Source1 => State::Source1S9,
        NonTermKind::Source0 => State::Source0S10,
        NonTermKind::Source => State::SourceS11,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::Prefix0S4
            )
        }
    }
}
fn goto_source1_s9(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Source => State::SourceS14,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::Source1S9
            )
        }
    }
}
fn goto_source0_s10(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Iterator1 => State::Iterator1S16,
        NonTermKind::Iterator0 => State::Iterator0S17,
        NonTermKind::Iterator => State::IteratorS18,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::Source0S10
            )
        }
    }
}
fn goto_iterator1_s16(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Iterator => State::IteratorS22,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::Iterator1S16
            )
        }
    }
}
fn goto_iterator0_s17(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression1 => State::Expression1S24,
        NonTermKind::Expression0 => State::Expression0S25,
        NonTermKind::Expression => State::ExpressionS26,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::Iterator0S17
            )
        }
    }
}
fn goto_expression1_s24(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Expression => State::ExpressionS31,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::Expression1S24
            )
        }
    }
}
fn goto_expression0_s25(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Shape1 => State::Shape1S33,
        NonTermKind::Shape0 => State::Shape0S34,
        NonTermKind::Shape => State::ShapeS35,
        NonTermKind::Subject => State::SubjectS36,
        NonTermKind::Class => State::ClassS37,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::Expression0S25
            )
        }
    }
}
fn goto_opentag_s29(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::PathLiteralOpt => State::PathLiteralOptS40,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::OpenTagS29
            )
        }
    }
}
fn goto_shape1_s33(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Shape => State::ShapeS43,
        NonTermKind::Subject => State::SubjectS36,
        NonTermKind::Class => State::ClassS37,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::Shape1S33
            )
        }
    }
}
fn goto_class_s37(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::SubjectIdentifier => State::SubjectIdentifierS46,
        NonTermKind::NamespaceOpt => State::NamespaceOptS47,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::ClassS37
            )
        }
    }
}
fn goto_opentag_s41(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::IteratorFileRelation1 => State::IteratorFileRelation1S50,
        NonTermKind::IteratorFileRelation => State::IteratorFileRelationS51,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::OpenTagS41
            )
        }
    }
}
fn goto_openbrace_s44(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::PredicateObject1 => State::PredicateObject1S53,
        NonTermKind::PredicateObject0 => State::PredicateObject0S54,
        NonTermKind::PredicateObject => State::PredicateObjectS55,
        NonTermKind::Predicate => State::PredicateS56,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::OpenBraceS44
            )
        }
    }
}
fn goto_predicateobject1_s53(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::PredicateObject => State::PredicateObjectS63,
        NonTermKind::Predicate => State::PredicateS56,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::PredicateObject1S53
            )
        }
    }
}
fn goto_predicate_s56(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::NamespaceOpt => State::NamespaceOptS66,
        NonTermKind::Object => State::ObjectS67,
        NonTermKind::DataValue => State::DataValueS68,
        NonTermKind::Reference => State::ReferenceS69,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::PredicateS56
            )
        }
    }
}
fn goto_unionliteral_s60(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::IteratorFileRelation => State::IteratorFileRelationS73,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::UnionLiteralS60
            )
        }
    }
}
fn goto_openbrace_s71(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Attribute1 => State::Attribute1S79,
        NonTermKind::Attribute => State::AttributeS80,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::OpenBraceS71
            )
        }
    }
}
fn goto_attribute1_s79(nonterm_kind: NonTermKind) -> State {
    match nonterm_kind {
        NonTermKind::Iterator1 => State::Iterator1S16,
        NonTermKind::Iterator0 => State::Iterator0S84,
        NonTermKind::Iterator => State::IteratorS18,
        NonTermKind::Attribute => State::AttributeS85,
        _ => {
            panic!(
                "Invalid terminal kind ({nonterm_kind:?}) for GOTO state ({:?}).",
                State::Attribute1S79
            )
        }
    }
}
fn goto_invalid(_nonterm_kind: NonTermKind) -> State {
    panic!("Invalid GOTO entry!");
}
pub(crate) static PARSER_DEFINITION: ShexmlParserDefinition = ShexmlParserDefinition {
    actions: [
        action_aug_s0,
        action_prefixliteral_s1,
        action_shexml_s2,
        action_prefix1_s3,
        action_prefix0_s4,
        action_prefix_s5,
        action_namespace_s6,
        action_prefix_s7,
        action_sourceliteral_s8,
        action_source1_s9,
        action_source0_s10,
        action_source_s11,
        action_opentag_s12,
        action_identifier_s13,
        action_source_s14,
        action_iteratorliteral_s15,
        action_iterator1_s16,
        action_iterator0_s17,
        action_iterator_s18,
        action_uri_s19,
        action_opentag_s20,
        action_identifier_s21,
        action_iterator_s22,
        action_expressionliteral_s23,
        action_expression1_s24,
        action_expression0_s25,
        action_expression_s26,
        action_closetag_s27,
        action_uri_s28,
        action_opentag_s29,
        action_identifier_s30,
        action_expression_s31,
        action_namespace_s32,
        action_shape1_s33,
        action_shape0_s34,
        action_shape_s35,
        action_subject_s36,
        action_class_s37,
        action_closetag_s38,
        action_pathliteral_s39,
        action_pathliteralopt_s40,
        action_opentag_s41,
        action_identifier_s42,
        action_shape_s43,
        action_openbrace_s44,
        action_namespace_s45,
        action_subjectidentifier_s46,
        action_namespaceopt_s47,
        action_path_s48,
        action_identifier_s49,
        action_iteratorfilerelation1_s50,
        action_iteratorfilerelation_s51,
        action_namespace_s52,
        action_predicateobject1_s53,
        action_predicateobject0_s54,
        action_predicateobject_s55,
        action_predicate_s56,
        action_openbracket_s57,
        action_closetag_s58,
        action_dot_s59,
        action_unionliteral_s60,
        action_closetag_s61,
        action_identifier_s62,
        action_predicateobject_s63,
        action_closebrace_s64,
        action_atsign_s65,
        action_namespaceopt_s66,
        action_object_s67,
        action_datavalue_s68,
        action_reference_s69,
        action_shapepath_s70,
        action_openbrace_s71,
        action_identifier_s72,
        action_iteratorfilerelation_s73,
        action_namespace_s74,
        action_openbracket_s75,
        action_semicolon_s76,
        action_closebracket_s77,
        action_fieldliteral_s78,
        action_attribute1_s79,
        action_attribute_s80,
        action_identifier_s81,
        action_shapepath_s82,
        action_identifier_s83,
        action_iterator0_s84,
        action_attribute_s85,
        action_closebracket_s86,
        action_opentag_s87,
        action_closebrace_s88,
        action_path_s89,
        action_closetag_s90,
    ],
    gotos: [
        goto_aug_s0,
        goto_invalid,
        goto_invalid,
        goto_prefix1_s3,
        goto_prefix0_s4,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_source1_s9,
        goto_source0_s10,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_iterator1_s16,
        goto_iterator0_s17,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_expression1_s24,
        goto_expression0_s25,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_opentag_s29,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_shape1_s33,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_class_s37,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_opentag_s41,
        goto_invalid,
        goto_invalid,
        goto_openbrace_s44,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_predicateobject1_s53,
        goto_invalid,
        goto_invalid,
        goto_predicate_s56,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_unionliteral_s60,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_openbrace_s71,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_attribute1_s79,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
        goto_invalid,
    ],
    token_kinds: [
        [
            Some((TK::STOP, true)),
            Some((TK::ExpressionLiteral, true)),
            Some((TK::IteratorLiteral, true)),
            Some((TK::PrefixLiteral, true)),
            Some((TK::SourceLiteral, true)),
            Some((TK::Namespace, false)),
        ],
        [Some((TK::Namespace, false)), None, None, None, None, None],
        [Some((TK::STOP, false)), None, None, None, None, None],
        [
            Some((TK::STOP, true)),
            Some((TK::ExpressionLiteral, true)),
            Some((TK::IteratorLiteral, true)),
            Some((TK::PrefixLiteral, true)),
            Some((TK::SourceLiteral, true)),
            Some((TK::Namespace, false)),
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::ExpressionLiteral, true)),
            Some((TK::IteratorLiteral, true)),
            Some((TK::SourceLiteral, true)),
            Some((TK::Namespace, false)),
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::ExpressionLiteral, true)),
            Some((TK::IteratorLiteral, true)),
            Some((TK::PrefixLiteral, true)),
            Some((TK::SourceLiteral, true)),
            Some((TK::Namespace, false)),
        ],
        [Some((TK::OpenTag, true)), None, None, None, None, None],
        [
            Some((TK::STOP, true)),
            Some((TK::ExpressionLiteral, true)),
            Some((TK::IteratorLiteral, true)),
            Some((TK::PrefixLiteral, true)),
            Some((TK::SourceLiteral, true)),
            Some((TK::Namespace, false)),
        ],
        [Some((TK::Identifier, false)), None, None, None, None, None],
        [
            Some((TK::STOP, true)),
            Some((TK::ExpressionLiteral, true)),
            Some((TK::IteratorLiteral, true)),
            Some((TK::SourceLiteral, true)),
            Some((TK::Namespace, false)),
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::ExpressionLiteral, true)),
            Some((TK::IteratorLiteral, true)),
            Some((TK::Namespace, false)),
            None,
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::ExpressionLiteral, true)),
            Some((TK::IteratorLiteral, true)),
            Some((TK::SourceLiteral, true)),
            Some((TK::Namespace, false)),
            None,
        ],
        [Some((TK::Uri, false)), None, None, None, None, None],
        [Some((TK::OpenTag, true)), None, None, None, None, None],
        [
            Some((TK::STOP, true)),
            Some((TK::ExpressionLiteral, true)),
            Some((TK::IteratorLiteral, true)),
            Some((TK::SourceLiteral, true)),
            Some((TK::Namespace, false)),
            None,
        ],
        [Some((TK::Identifier, false)), None, None, None, None, None],
        [
            Some((TK::STOP, true)),
            Some((TK::ExpressionLiteral, true)),
            Some((TK::IteratorLiteral, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Namespace, false)),
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::ExpressionLiteral, true)),
            Some((TK::Namespace, false)),
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::ExpressionLiteral, true)),
            Some((TK::IteratorLiteral, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Namespace, false)),
            None,
        ],
        [Some((TK::CloseTag, true)), None, None, None, None, None],
        [Some((TK::Uri, false)), None, None, None, None, None],
        [Some((TK::OpenTag, true)), None, None, None, None, None],
        [
            Some((TK::STOP, true)),
            Some((TK::ExpressionLiteral, true)),
            Some((TK::IteratorLiteral, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Namespace, false)),
            None,
        ],
        [Some((TK::Identifier, false)), None, None, None, None, None],
        [
            Some((TK::STOP, true)),
            Some((TK::ExpressionLiteral, true)),
            Some((TK::Namespace, false)),
            None,
            None,
            None,
        ],
        [Some((TK::STOP, true)), Some((TK::Namespace, false)), None, None, None, None],
        [
            Some((TK::STOP, true)),
            Some((TK::ExpressionLiteral, true)),
            Some((TK::Namespace, false)),
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::ExpressionLiteral, true)),
            Some((TK::IteratorLiteral, true)),
            Some((TK::PrefixLiteral, true)),
            Some((TK::SourceLiteral, true)),
            Some((TK::Namespace, false)),
        ],
        [Some((TK::CloseTag, true)), None, None, None, None, None],
        [
            Some((TK::PathLiteral, false)),
            Some((TK::Path, false)),
            None,
            None,
            None,
            None,
        ],
        [Some((TK::OpenTag, true)), None, None, None, None, None],
        [
            Some((TK::STOP, true)),
            Some((TK::ExpressionLiteral, true)),
            Some((TK::Namespace, false)),
            None,
            None,
            None,
        ],
        [Some((TK::Identifier, false)), None, None, None, None, None],
        [Some((TK::STOP, true)), Some((TK::Namespace, false)), None, None, None, None],
        [Some((TK::STOP, false)), None, None, None, None, None],
        [Some((TK::STOP, true)), Some((TK::Namespace, false)), None, None, None, None],
        [Some((TK::OpenBrace, true)), None, None, None, None, None],
        [
            Some((TK::OpenBracket, true)),
            Some((TK::Namespace, false)),
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::STOP, true)),
            Some((TK::ExpressionLiteral, true)),
            Some((TK::IteratorLiteral, true)),
            Some((TK::SourceLiteral, true)),
            Some((TK::Namespace, false)),
            None,
        ],
        [Some((TK::Path, false)), None, None, None, None, None],
        [Some((TK::Path, false)), None, None, None, None, None],
        [Some((TK::Identifier, false)), None, None, None, None, None],
        [
            Some((TK::OpenBracket, true)),
            Some((TK::Namespace, false)),
            None,
            None,
            None,
            None,
        ],
        [Some((TK::STOP, true)), Some((TK::Namespace, false)), None, None, None, None],
        [
            Some((TK::CloseBrace, true)),
            Some((TK::Namespace, false)),
            None,
            None,
            None,
            None,
        ],
        [Some((TK::OpenBracket, true)), None, None, None, None, None],
        [Some((TK::OpenBrace, true)), None, None, None, None, None],
        [Some((TK::OpenBracket, true)), None, None, None, None, None],
        [Some((TK::CloseTag, true)), None, None, None, None, None],
        [Some((TK::Dot, true)), None, None, None, None, None],
        [
            Some((TK::UnionLiteral, true)),
            Some((TK::CloseTag, true)),
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::UnionLiteral, true)),
            Some((TK::CloseTag, true)),
            None,
            None,
            None,
            None,
        ],
        [Some((TK::Identifier, false)), None, None, None, None, None],
        [
            Some((TK::CloseBrace, true)),
            Some((TK::Namespace, false)),
            None,
            None,
            None,
            None,
        ],
        [Some((TK::CloseBrace, true)), None, None, None, None, None],
        [
            Some((TK::CloseBrace, true)),
            Some((TK::Namespace, false)),
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::OpenBracket, true)),
            Some((TK::AtSign, true)),
            Some((TK::Namespace, false)),
            None,
            None,
            None,
        ],
        [Some((TK::ShapePath, false)), None, None, None, None, None],
        [Some((TK::OpenBrace, true)), None, None, None, None, None],
        [Some((TK::Identifier, false)), None, None, None, None, None],
        [Some((TK::Identifier, false)), None, None, None, None, None],
        [
            Some((TK::STOP, true)),
            Some((TK::ExpressionLiteral, true)),
            Some((TK::Namespace, false)),
            None,
            None,
            None,
        ],
        [
            Some((TK::OpenBracket, true)),
            Some((TK::AtSign, true)),
            Some((TK::Namespace, false)),
            None,
            None,
            None,
        ],
        [
            Some((TK::CloseBrace, true)),
            Some((TK::Namespace, false)),
            None,
            None,
            None,
            None,
        ],
        [Some((TK::STOP, true)), Some((TK::Namespace, false)), None, None, None, None],
        [Some((TK::Namespace, false)), None, None, None, None, None],
        [Some((TK::OpenBracket, true)), None, None, None, None, None],
        [Some((TK::Semicolon, true)), None, None, None, None, None],
        [Some((TK::Semicolon, true)), None, None, None, None, None],
        [Some((TK::Semicolon, true)), None, None, None, None, None],
        [Some((TK::CloseBracket, true)), None, None, None, None, None],
        [Some((TK::FieldLiteral, true)), None, None, None, None, None],
        [
            Some((TK::UnionLiteral, true)),
            Some((TK::CloseTag, true)),
            None,
            None,
            None,
            None,
        ],
        [
            Some((TK::UnionLiteral, true)),
            Some((TK::CloseTag, true)),
            None,
            None,
            None,
            None,
        ],
        [Some((TK::Identifier, false)), None, None, None, None, None],
        [Some((TK::ShapePath, false)), None, None, None, None, None],
        [
            Some((TK::CloseBrace, true)),
            Some((TK::Namespace, false)),
            None,
            None,
            None,
            None,
        ],
        [Some((TK::OpenBrace, true)), None, None, None, None, None],
        [Some((TK::Identifier, false)), None, None, None, None, None],
        [
            Some((TK::IteratorLiteral, true)),
            Some((TK::FieldLiteral, true)),
            Some((TK::CloseBrace, true)),
            None,
            None,
            None,
        ],
        [
            Some((TK::IteratorLiteral, true)),
            Some((TK::FieldLiteral, true)),
            Some((TK::CloseBrace, true)),
            None,
            None,
            None,
        ],
        [Some((TK::Semicolon, true)), None, None, None, None, None],
        [Some((TK::CloseBracket, true)), None, None, None, None, None],
        [Some((TK::OpenTag, true)), None, None, None, None, None],
        [Some((TK::CloseBrace, true)), None, None, None, None, None],
        [
            Some((TK::IteratorLiteral, true)),
            Some((TK::FieldLiteral, true)),
            Some((TK::CloseBrace, true)),
            None,
            None,
            None,
        ],
        [Some((TK::Semicolon, true)), None, None, None, None, None],
        [Some((TK::Path, false)), None, None, None, None, None],
        [
            Some((TK::STOP, true)),
            Some((TK::ExpressionLiteral, true)),
            Some((TK::IteratorLiteral, true)),
            Some((TK::CloseBrace, true)),
            Some((TK::Namespace, false)),
            None,
        ],
        [Some((TK::CloseTag, true)), None, None, None, None, None],
        [
            Some((TK::IteratorLiteral, true)),
            Some((TK::FieldLiteral, true)),
            Some((TK::CloseBrace, true)),
            None,
            None,
            None,
        ],
    ],
};
impl ParserDefinition<State, ProdKind, TokenKind, NonTermKind>
for ShexmlParserDefinition {
    fn actions(&self, state: State, token: TokenKind) -> Vec<Action<State, ProdKind>> {
        PARSER_DEFINITION.actions[state as usize](token)
    }
    fn goto(&self, state: State, nonterm: NonTermKind) -> State {
        PARSER_DEFINITION.gotos[state as usize](nonterm)
    }
    fn expected_token_kinds(&self, state: State) -> Vec<(TokenKind, bool)> {
        PARSER_DEFINITION.token_kinds[state as usize].iter().map_while(|t| *t).collect()
    }
    fn longest_match() -> bool {
        true
    }
    fn grammar_order() -> bool {
        true
    }
}
pub(crate) type Context<'i, I> = LRContext<'i, I, State, TokenKind>;
pub struct ShexmlParser<
    'i,
    I: InputT + ?Sized,
    L: Lexer<'i, Context<'i, I>, State, TokenKind, Input = I>,
    B,
>(
    LRParser<
        'i,
        Context<'i, I>,
        State,
        ProdKind,
        TokenKind,
        NonTermKind,
        ShexmlParserDefinition,
        L,
        B,
        I,
    >,
);
#[allow(dead_code)]
impl<
    'i,
> ShexmlParser<
    'i,
    Input,
    StringLexer<Context<'i, Input>, State, TokenKind, TokenRecognizer, TERMINAL_COUNT>,
    DefaultBuilder,
> {
    pub fn new() -> Self {
        Self(
            LRParser::new(
                &PARSER_DEFINITION,
                State::default(),
                false,
                false,
                StringLexer::new(true, &RECOGNIZERS),
                DefaultBuilder::new(),
            ),
        )
    }
}
#[allow(dead_code)]
impl<'i, I, L, B> Parser<'i, I, Context<'i, I>, State, TokenKind>
for ShexmlParser<'i, I, L, B>
where
    I: InputT + ?Sized + Debug,
    L: Lexer<'i, Context<'i, I>, State, TokenKind, Input = I>,
    B: LRBuilder<'i, I, Context<'i, I>, State, ProdKind, TokenKind>,
{
    type Output = B::Output;
    fn parse(&self, input: &'i I) -> Result<Self::Output> {
        self.0.parse(input)
    }
    fn parse_with_context(
        &self,
        context: &mut Context<'i, I>,
        input: &'i I,
    ) -> Result<Self::Output> {
        self.0.parse_with_context(context, input)
    }
    fn parse_file<'a, F: AsRef<std::path::Path>>(
        &'a mut self,
        file: F,
    ) -> Result<Self::Output>
    where
        'a: 'i,
    {
        self.0.parse_file(file)
    }
}
#[allow(dead_code)]
#[derive(Debug)]
pub enum Recognizer {
    Stop,
    StrMatch(&'static str),
    RegexMatch(Lazy<Regex>),
}
#[allow(dead_code)]
#[derive(Debug)]
pub struct TokenRecognizer(TokenKind, Recognizer);
impl<'i> TokenRecognizerT<'i> for TokenRecognizer {
    fn recognize(&self, input: &'i str) -> Option<&'i str> {
        match &self {
            #[allow(unused_variables)]
            TokenRecognizer(token_kind, Recognizer::StrMatch(s)) => {
                logn!("{} {:?} -- ", "    Recognizing".green(), token_kind);
                if input.starts_with(s) {
                    log!("{}", "recognized".bold().green());
                    Some(s)
                } else {
                    log!("{}", "not recognized".red());
                    None
                }
            }
            #[allow(unused_variables)]
            TokenRecognizer(token_kind, Recognizer::RegexMatch(r)) => {
                logn!("{} {:?} -- ", "    Recognizing".green(), token_kind);
                let match_str = r.find(input);
                match match_str {
                    Some(x) => {
                        let x_str = x.as_str();
                        log!("{} '{}'", "recognized".bold().green(), x_str);
                        Some(x_str)
                    }
                    _ => {
                        log!("{}", "not recognized".red());
                        None
                    }
                }
            }
            TokenRecognizer(_, Recognizer::Stop) => {
                logn!("{} STOP -- ", "    Recognizing".green());
                if input.is_empty() {
                    log!("{}", "recognized".bold().green());
                    Some("")
                } else {
                    log!("{}", "not recognized".red());
                    None
                }
            }
        }
    }
}
pub(crate) static RECOGNIZERS: [TokenRecognizer; TERMINAL_COUNT] = [
    TokenRecognizer(TokenKind::STOP, Recognizer::Stop),
    TokenRecognizer(TokenKind::PrefixLiteral, Recognizer::StrMatch("PREFIX")),
    TokenRecognizer(TokenKind::SourceLiteral, Recognizer::StrMatch("SOURCE")),
    TokenRecognizer(TokenKind::IteratorLiteral, Recognizer::StrMatch("ITERATOR")),
    TokenRecognizer(TokenKind::FieldLiteral, Recognizer::StrMatch("FIELD")),
    TokenRecognizer(TokenKind::ExpressionLiteral, Recognizer::StrMatch("EXPRESSION")),
    TokenRecognizer(TokenKind::UnionLiteral, Recognizer::StrMatch("UNION")),
    TokenRecognizer(TokenKind::OpenTag, Recognizer::StrMatch("<")),
    TokenRecognizer(TokenKind::CloseTag, Recognizer::StrMatch(">")),
    TokenRecognizer(TokenKind::OpenBrace, Recognizer::StrMatch("{")),
    TokenRecognizer(TokenKind::CloseBrace, Recognizer::StrMatch("}")),
    TokenRecognizer(TokenKind::OpenBracket, Recognizer::StrMatch("[")),
    TokenRecognizer(TokenKind::CloseBracket, Recognizer::StrMatch("]")),
    TokenRecognizer(TokenKind::AtSign, Recognizer::StrMatch("@")),
    TokenRecognizer(TokenKind::Dots, Recognizer::StrMatch(":")),
    TokenRecognizer(TokenKind::Semicolon, Recognizer::StrMatch(";")),
    TokenRecognizer(
        TokenKind::Namespace,
        Recognizer::RegexMatch(
            Lazy::new(|| { Regex::new(concat!("^", "[a-zA-Z0-9\\-_]*:")).unwrap() }),
        ),
    ),
    TokenRecognizer(
        TokenKind::Identifier,
        Recognizer::RegexMatch(
            Lazy::new(|| { Regex::new(concat!("^", "[a-zA-Z0-9\\-_]*")).unwrap() }),
        ),
    ),
    TokenRecognizer(
        TokenKind::PathLiteral,
        Recognizer::RegexMatch(
            Lazy::new(|| { Regex::new(concat!("^", "xpath:|jsonpath:")).unwrap() }),
        ),
    ),
    TokenRecognizer(
        TokenKind::Path,
        Recognizer::RegexMatch(
            Lazy::new(|| {
                Regex::new(concat!("^", "[/.@\\$\\[\\]a-zA-Z0-9_\\*\\-'\"]+")).unwrap()
            }),
        ),
    ),
    TokenRecognizer(
        TokenKind::ShapePath,
        Recognizer::RegexMatch(
            Lazy::new(|| { Regex::new(concat!("^", "[/.a-zA-Z0-9_\\*\\-]+")).unwrap() }),
        ),
    ),
    TokenRecognizer(
        TokenKind::Uri,
        Recognizer::RegexMatch(
            Lazy::new(|| { Regex::new(concat!("^", "https?://[^\\s<>\"]+")).unwrap() }),
        ),
    ),
    TokenRecognizer(TokenKind::Dot, Recognizer::StrMatch(".")),
];
pub struct DefaultBuilder {
    res_stack: Vec<Symbol>,
}
impl DefaultBuilder {
    #[allow(dead_code)]
    pub fn new() -> Self {
        Self { res_stack: vec![] }
    }
}
impl Builder for DefaultBuilder {
    type Output = shexml_actions::Shexml;
    fn get_result(&mut self) -> Self::Output {
        match self.res_stack.pop().unwrap() {
            Symbol::NonTerminal(NonTerminal::Shexml(r)) => r,
            _ => panic!("Invalid result on the parse stack!"),
        }
    }
}
impl<'i> LRBuilder<'i, Input, Context<'i, Input>, State, ProdKind, TokenKind>
for DefaultBuilder {
    #![allow(unused_variables)]
    fn shift_action(
        &mut self,
        context: &Context<'i, Input>,
        token: Token<'i, Input, TokenKind>,
    ) {
        let val = match token.kind {
            TokenKind::STOP => panic!("Cannot shift STOP token!"),
            TokenKind::PrefixLiteral => Terminal::PrefixLiteral,
            TokenKind::SourceLiteral => Terminal::SourceLiteral,
            TokenKind::IteratorLiteral => Terminal::IteratorLiteral,
            TokenKind::FieldLiteral => Terminal::FieldLiteral,
            TokenKind::ExpressionLiteral => Terminal::ExpressionLiteral,
            TokenKind::UnionLiteral => Terminal::UnionLiteral,
            TokenKind::OpenTag => Terminal::OpenTag,
            TokenKind::CloseTag => Terminal::CloseTag,
            TokenKind::OpenBrace => Terminal::OpenBrace,
            TokenKind::CloseBrace => Terminal::CloseBrace,
            TokenKind::OpenBracket => Terminal::OpenBracket,
            TokenKind::CloseBracket => Terminal::CloseBracket,
            TokenKind::AtSign => Terminal::AtSign,
            TokenKind::Semicolon => Terminal::Semicolon,
            TokenKind::Namespace => {
                Terminal::Namespace(shexml_actions::namespace(context, token))
            }
            TokenKind::Identifier => {
                Terminal::Identifier(shexml_actions::identifier(context, token))
            }
            TokenKind::PathLiteral => {
                Terminal::PathLiteral(shexml_actions::path_literal(context, token))
            }
            TokenKind::Path => Terminal::Path(shexml_actions::path(context, token)),
            TokenKind::ShapePath => {
                Terminal::ShapePath(shexml_actions::shape_path(context, token))
            }
            TokenKind::Uri => Terminal::Uri(shexml_actions::uri(context, token)),
            TokenKind::Dot => Terminal::Dot,
            _ => panic!("Shift of unreachable terminal!"),
        };
        self.res_stack.push(Symbol::Terminal(val));
    }
    fn reduce_action(
        &mut self,
        context: &Context<'i, Input>,
        prod: ProdKind,
        prod_len: usize,
    ) {
        let prod = match prod {
            ProdKind::ShexmlP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 5usize)
                    .into_iter();
                match (
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                ) {
                    (
                        Symbol::NonTerminal(NonTerminal::Prefix0(p0)),
                        Symbol::NonTerminal(NonTerminal::Source0(p1)),
                        Symbol::NonTerminal(NonTerminal::Iterator0(p2)),
                        Symbol::NonTerminal(NonTerminal::Expression0(p3)),
                        Symbol::NonTerminal(NonTerminal::Shape0(p4)),
                    ) => {
                        NonTerminal::Shexml(
                            shexml_actions::shexml_c1(context, p0, p1, p2, p3, p4),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Prefix1P1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::Prefix1(p0)),
                        Symbol::NonTerminal(NonTerminal::Prefix(p1)),
                    ) => {
                        NonTerminal::Prefix1(shexml_actions::prefix1_c1(context, p0, p1))
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Prefix1P2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::Prefix(p0)) => {
                        NonTerminal::Prefix1(shexml_actions::prefix1_prefix(context, p0))
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Prefix0P1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::Prefix1(p0)) => {
                        NonTerminal::Prefix0(
                            shexml_actions::prefix0_prefix1(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Prefix0P2 => {
                NonTerminal::Prefix0(shexml_actions::prefix0_empty(context))
            }
            ProdKind::Source1P1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::Source1(p0)),
                        Symbol::NonTerminal(NonTerminal::Source(p1)),
                    ) => {
                        NonTerminal::Source1(shexml_actions::source1_c1(context, p0, p1))
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Source1P2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::Source(p0)) => {
                        NonTerminal::Source1(shexml_actions::source1_source(context, p0))
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Source0P1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::Source1(p0)) => {
                        NonTerminal::Source0(
                            shexml_actions::source0_source1(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Source0P2 => {
                NonTerminal::Source0(shexml_actions::source0_empty(context))
            }
            ProdKind::Iterator1P1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::Iterator1(p0)),
                        Symbol::NonTerminal(NonTerminal::Iterator(p1)),
                    ) => {
                        NonTerminal::Iterator1(
                            shexml_actions::iterator1_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Iterator1P2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::Iterator(p0)) => {
                        NonTerminal::Iterator1(
                            shexml_actions::iterator1_iterator(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Iterator0P1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::Iterator1(p0)) => {
                        NonTerminal::Iterator0(
                            shexml_actions::iterator0_iterator1(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Iterator0P2 => {
                NonTerminal::Iterator0(shexml_actions::iterator0_empty(context))
            }
            ProdKind::Expression1P1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::Expression1(p0)),
                        Symbol::NonTerminal(NonTerminal::Expression(p1)),
                    ) => {
                        NonTerminal::Expression1(
                            shexml_actions::expression1_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Expression1P2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::Expression(p0)) => {
                        NonTerminal::Expression1(
                            shexml_actions::expression1_expression(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Expression0P1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::Expression1(p0)) => {
                        NonTerminal::Expression0(
                            shexml_actions::expression0_expression1(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Expression0P2 => {
                NonTerminal::Expression0(shexml_actions::expression0_empty(context))
            }
            ProdKind::Shape1P1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::Shape1(p0)),
                        Symbol::NonTerminal(NonTerminal::Shape(p1)),
                    ) => NonTerminal::Shape1(shexml_actions::shape1_c1(context, p0, p1)),
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Shape1P2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::Shape(p0)) => {
                        NonTerminal::Shape1(shexml_actions::shape1_shape(context, p0))
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Shape0P1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::Shape1(p0)) => {
                        NonTerminal::Shape0(shexml_actions::shape0_shape1(context, p0))
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Shape0P2 => {
                NonTerminal::Shape0(shexml_actions::shape0_empty(context))
            }
            ProdKind::PrefixP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 5usize)
                    .into_iter();
                match (
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                ) {
                    (
                        _,
                        Symbol::Terminal(Terminal::Namespace(p0)),
                        _,
                        Symbol::Terminal(Terminal::Uri(p1)),
                        _,
                    ) => NonTerminal::Prefix(shexml_actions::prefix_c1(context, p0, p1)),
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::SourceP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 5usize)
                    .into_iter();
                match (
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                ) {
                    (
                        _,
                        Symbol::Terminal(Terminal::Identifier(p0)),
                        _,
                        Symbol::Terminal(Terminal::Uri(p1)),
                        _,
                    ) => NonTerminal::Source(shexml_actions::source_c1(context, p0, p1)),
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ExpressionP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 5usize)
                    .into_iter();
                match (
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                ) {
                    (
                        _,
                        Symbol::Terminal(Terminal::Identifier(p0)),
                        _,
                        Symbol::NonTerminal(NonTerminal::IteratorFileRelation1(p1)),
                        _,
                    ) => {
                        NonTerminal::Expression(
                            shexml_actions::expression_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::IteratorFileRelation1P1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 3usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::IteratorFileRelation1(p0)),
                        _,
                        Symbol::NonTerminal(NonTerminal::IteratorFileRelation(p1)),
                    ) => {
                        NonTerminal::IteratorFileRelation1(
                            shexml_actions::iterator_file_relation1_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::IteratorFileRelation1P2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::IteratorFileRelation(p0)) => {
                        NonTerminal::IteratorFileRelation1(
                            shexml_actions::iterator_file_relation1_iterator_file_relation(
                                context,
                                p0,
                            ),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::IteratorFileRelationP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 3usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::Terminal(Terminal::Identifier(p0)),
                        _,
                        Symbol::Terminal(Terminal::Identifier(p1)),
                    ) => {
                        NonTerminal::IteratorFileRelation(
                            shexml_actions::iterator_file_relation_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::IteratorP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 10usize)
                    .into_iter();
                match (
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                ) {
                    (
                        _,
                        Symbol::Terminal(Terminal::Identifier(p0)),
                        _,
                        Symbol::NonTerminal(NonTerminal::PathLiteralOpt(p1)),
                        Symbol::Terminal(Terminal::Path(p2)),
                        _,
                        _,
                        Symbol::NonTerminal(NonTerminal::Attribute1(p3)),
                        Symbol::NonTerminal(NonTerminal::Iterator0(p4)),
                        _,
                    ) => {
                        NonTerminal::Iterator(
                            shexml_actions::iterator_c1(context, p0, p1, p2, p3, p4),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::PathLiteralOptP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::Terminal(Terminal::PathLiteral(p0)) => {
                        NonTerminal::PathLiteralOpt(
                            shexml_actions::path_literal_opt_path_literal(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::PathLiteralOptP2 => {
                NonTerminal::PathLiteralOpt(
                    shexml_actions::path_literal_opt_empty(context),
                )
            }
            ProdKind::Attribute1P1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::Attribute1(p0)),
                        Symbol::NonTerminal(NonTerminal::Attribute(p1)),
                    ) => {
                        NonTerminal::Attribute1(
                            shexml_actions::attribute1_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::Attribute1P2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::Attribute(p0)) => {
                        NonTerminal::Attribute1(
                            shexml_actions::attribute1_attribute(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::AttributeP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 5usize)
                    .into_iter();
                match (
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                ) {
                    (
                        _,
                        Symbol::Terminal(Terminal::Identifier(p0)),
                        _,
                        Symbol::Terminal(Terminal::Path(p1)),
                        _,
                    ) => {
                        NonTerminal::Attribute(
                            shexml_actions::attribute_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ShapeP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 4usize)
                    .into_iter();
                match (
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                ) {
                    (
                        Symbol::NonTerminal(NonTerminal::Subject(p0)),
                        _,
                        Symbol::NonTerminal(NonTerminal::PredicateObject0(p1)),
                        _,
                    ) => NonTerminal::Shape(shexml_actions::shape_c1(context, p0, p1)),
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::PredicateObject1P1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::PredicateObject1(p0)),
                        Symbol::NonTerminal(NonTerminal::PredicateObject(p1)),
                    ) => {
                        NonTerminal::PredicateObject1(
                            shexml_actions::predicate_object1_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::PredicateObject1P2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::PredicateObject(p0)) => {
                        NonTerminal::PredicateObject1(
                            shexml_actions::predicate_object1_predicate_object(
                                context,
                                p0,
                            ),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::PredicateObject0P1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::PredicateObject1(p0)) => {
                        NonTerminal::PredicateObject0(
                            shexml_actions::predicate_object0_predicate_object1(
                                context,
                                p0,
                            ),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::PredicateObject0P2 => {
                NonTerminal::PredicateObject0(
                    shexml_actions::predicate_object0_empty(context),
                )
            }
            ProdKind::SubjectP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::Class(p0)),
                        Symbol::NonTerminal(NonTerminal::SubjectIdentifier(p1)),
                    ) => {
                        NonTerminal::Subject(shexml_actions::subject_c1(context, p0, p1))
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ClassP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::Terminal(Terminal::Namespace(p0)),
                        Symbol::Terminal(Terminal::Identifier(p1)),
                    ) => NonTerminal::Class(shexml_actions::class_c1(context, p0, p1)),
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::SubjectIdentifierP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 4usize)
                    .into_iter();
                match (
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                ) {
                    (
                        Symbol::NonTerminal(NonTerminal::NamespaceOpt(p0)),
                        _,
                        Symbol::Terminal(Terminal::ShapePath(p1)),
                        _,
                    ) => {
                        NonTerminal::SubjectIdentifier(
                            shexml_actions::subject_identifier_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::NamespaceOptP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::Terminal(Terminal::Namespace(p0)) => {
                        NonTerminal::NamespaceOpt(
                            shexml_actions::namespace_opt_namespace(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::NamespaceOptP2 => {
                NonTerminal::NamespaceOpt(shexml_actions::namespace_opt_empty(context))
            }
            ProdKind::PredicateObjectP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 3usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::NonTerminal(NonTerminal::Predicate(p0)),
                        Symbol::NonTerminal(NonTerminal::Object(p1)),
                        _,
                    ) => {
                        NonTerminal::PredicateObject(
                            shexml_actions::predicate_object_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::PredicateP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 2usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap()) {
                    (
                        Symbol::Terminal(Terminal::Namespace(p0)),
                        Symbol::Terminal(Terminal::Identifier(p1)),
                    ) => {
                        NonTerminal::Predicate(
                            shexml_actions::predicate_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ObjectP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::DataValue(p0)) => {
                        NonTerminal::Object(
                            shexml_actions::object_data_value(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ObjectP2 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 1usize)
                    .into_iter();
                match i.next().unwrap() {
                    Symbol::NonTerminal(NonTerminal::Reference(p0)) => {
                        NonTerminal::Object(
                            shexml_actions::object_reference(context, p0),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::DataValueP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 4usize)
                    .into_iter();
                match (
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                    i.next().unwrap(),
                ) {
                    (
                        Symbol::NonTerminal(NonTerminal::NamespaceOpt(p0)),
                        _,
                        Symbol::Terminal(Terminal::ShapePath(p1)),
                        _,
                    ) => {
                        NonTerminal::DataValue(
                            shexml_actions::data_value_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
            ProdKind::ReferenceP1 => {
                let mut i = self
                    .res_stack
                    .split_off(self.res_stack.len() - 3usize)
                    .into_iter();
                match (i.next().unwrap(), i.next().unwrap(), i.next().unwrap()) {
                    (
                        _,
                        Symbol::Terminal(Terminal::Namespace(p0)),
                        Symbol::Terminal(Terminal::Identifier(p1)),
                    ) => {
                        NonTerminal::Reference(
                            shexml_actions::reference_c1(context, p0, p1),
                        )
                    }
                    _ => panic!("Invalid symbol parse stack data."),
                }
            }
        };
        self.res_stack.push(Symbol::NonTerminal(prod));
    }
}
